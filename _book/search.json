[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Análisis Criminológico de Datos",
    "section": "",
    "text": "Introducción\nEste libro tiene como objetivo apoyar la capacitación a los integrantes de la Subsecretaría de Prevención del Delito en el curso de Análisis criminológico de datos. A través de una guía práctica, se proporcionará a los lectores las habilidades necesarias para limpiar, estructurar y analizar datos de una manera rigurosa y efectiva. El libro está diseñado para proporcionar una comprensión sólida de las técnicas de análisis exploratorio y descriptivo de datos, así como de las técnicas de limpieza y transformación de datos."
  },
  {
    "objectID": "index.html#objetivos-del-curso",
    "href": "index.html#objetivos-del-curso",
    "title": "Análisis Criminológico de Datos",
    "section": "Objetivos del curso",
    "text": "Objetivos del curso\nEl Objetivo General de aprendizaje este curso es aplicar herramientas eficientes para el trabajo con grandes volúmenes de datos, aplicándolos al análisis de patrones territoriales y tendencias delictuales.\nObjetivos específicos: \n\nAbrir datos de formato diverso, limpiarlos, estructurarlos y concatenarlos, en R.\nGenerar indicadores y series longitudinales con datos de panel, en R.\nExportar datos agregados a .csv y .shp, para analizar casos territoriales en otros programas.\n\nSe evaluará la aplicación de estas herramientas al análisis personal de casos territoriales."
  },
  {
    "objectID": "syllabus.html#objetivos-del-curso",
    "href": "syllabus.html#objetivos-del-curso",
    "title": "Syllabus",
    "section": "Objetivos del curso",
    "text": "Objetivos del curso\nEl Objetivo General de aprendizaje este curso es aplicar herramientas eficientes para el trabajo con grandes volúmenes de datos, aplicándolos al análisis de patrones territoriales y tendencias delictuales.\nObjetivos específicos: \n\nAbrir datos de formato diverso, limpiarlos, estructurarlos y concatenarlos, en R.\nGenerar indicadores y series longitudinales con datos de panel, en R.\nExportar datos agregados a .csv y .shp, para analizar casos territoriales en otros programas.\n\nSe evaluará la aplicación de estas herramientas al análisis personal de casos territoriales."
  },
  {
    "objectID": "syllabus.html#metodología",
    "href": "syllabus.html#metodología",
    "title": "Syllabus",
    "section": "Metodología",
    "text": "Metodología\n\nEl curso considera sesiones de 1- hora 20, las que se desarrollarán en modalidad presencial teórica de 9:00 a 10:20 y en online en vivo práctica de 11:30 a 12:50 respectivamente. Los días martes se considera una sesión de 1 hora y 20 minutos de trabajo asistido online.\nDe esta manera cada semana tendrá tres partes: una teórica, en la que se explicarán los conceptos fundamentales de la criminología espacial, y otra práctica, en la que los alumnos podrán aplicar las metodologías de análisis espacial estudiadas mediante herramientas de programación con la orientación del profesor y finalmente desarrollar trabajo autónomo asistido por un docente."
  },
  {
    "objectID": "syllabus.html#evaluaciones",
    "href": "syllabus.html#evaluaciones",
    "title": "Syllabus",
    "section": "Evaluaciones",
    "text": "Evaluaciones\nEl proceso evaluativo de este curso se basa en la comprensión de que este debe ser continuo y estar ligado al desarrollo de los aprendizajes y no unilateralmente a la calificación. Cada actividad evaluativa tendrá etapas de profundización progresiva y acompañamiento al estudiante para la mejora.\n\nSe realizarán dos tareas que contarán con una ponderación del 30% cada una. Estas tareas estarán diseñadas para evaluar la comprensión de los conceptos clave y la aplicación de los mismos a situaciones prácticas.\nSe llevará a cabo un trabajo final que tendrá un peso del 40% en la nota final. Este trabajo final será una oportunidad para profundizar en una zona urbana de interés y demostrar la capacidad de análisis y síntesis de los contenidos del curso."
  },
  {
    "objectID": "syllabus.html#sesiones",
    "href": "syllabus.html#sesiones",
    "title": "Syllabus",
    "section": "Sesiones",
    "text": "Sesiones\n\n\n\n\n\n\n\n\nFecha\nHorario\nModalidad\nTema\n\n\n\n\n01-09-23\n9h00 - 10h20\nPresencial teórica\nBienvenida. Introducción a la Criminología desde la economía política, la sociología y la geografía.\n\n\n05-09-23\n11h00 - 12h20\nSincrónica Online práctica\nLectura de datos en formato entregado por Carabineros, limpieza, transformación y estructuración de datos en R.\n\n\n05-09-23\n15h00 - 16h20\nSincrónica Online asistida\nTarea 1: estructurar datos de casos policiales por zona censal y de denuncia seguro por comunas en el año 2022\n\n\n08-09-23\n9h00 - 10h20\nPresencial teórica\nCrimen organizado, evolución global y en teórica América Latina\n\n\n08-09-23\n11h30 - 12h50\nSincrónica Online práctica\nEstructuración y análisis de paneles de datos 1, en R.\n\n\n12-09-23\n15h00 - 16h20\nSincrónica Online asistida\nTarea 2: analizar tendencias de casos policiales y de denuncia seguro, por regiones, en el período 2017-2022\n\n\n15-09-23\n9h00 - 10h20\nPresencial teórica\nEvolución de tendencias criminales en Chile 2017-2022\n\n\n15-09-23\n11h30 - 12h50\nSincrónica Online práctica\nEstructuración y análisis de paneles de datos 2, R y exportación a Excel.\n\n\n26-09-23\n15h00 - 16h20\nSincrónica Online asistida\nProfundización de tarea 2.\n\n\n29-09-23\n9h00 - 10h20\nPresencial teórica\nEconomía política y sociología del poder en las organizaciones criminales\n\n\n29-09-23\n11h30 - 12h50\nSincrónica Online práctica\nCálculo de indicadores territoriales de evolución criminal y exportación a Shapefile.\n\n\n03-10-23\n15h00 - 16h20\nSincrónica Online asistida\nSincrónica Online asistida\n\n\n06-10-23\n9h00 - 10h20\nPresencial teórica\nSíntesis y discusión del curso\n\n\n06-10-23\n11h30 - 12h50\nSincrónica Online práctica\nRepresentación estadística y cartográfica de evolución criminal.\n\n\n10-10-23\n15h00 - 16h20\nSincrónica Online asistida\nProfundización de trabajo final.\n\n\n13-10-23\n9h00 - 11h30\nPresencial integradora\nSeminario abierto con autoridades y colegas. Presentación de trabajos."
  },
  {
    "objectID": "syllabus.html#horarios",
    "href": "syllabus.html#horarios",
    "title": "Syllabus",
    "section": "Horarios",
    "text": "Horarios\nSeptiembre:\n\n\n\nOctubre:"
  },
  {
    "objectID": "syllabus.html#reglamento",
    "href": "syllabus.html#reglamento",
    "title": "Syllabus",
    "section": "Reglamento",
    "text": "Reglamento\nAdministrativamente el Curso se guía por el Reglamento Académico y el código de Honor de la UAI. Los requisitos de aprobación son los siguientes:\n\n75% de Asistencia (el éxito del curso requiere de la asistencia y participación de los alumnos en las discusiones).\nPromedio final mínimo de 4,0."
  },
  {
    "objectID": "datos.html#introducción",
    "href": "datos.html#introducción",
    "title": "1  Datos",
    "section": "1.1 Introducción",
    "text": "1.1 Introducción\nLa lectura y limpieza de datos es una tarea fundamental en el análisis de datos, ya que los datos pueden contener errores, valores faltantes, duplicados o información inconsistente. Estos problemas pueden afectar la calidad de los resultados obtenidos a partir del análisis y, en algunos casos, incluso invalidar las conclusiones. Por lo tanto, es importante que los datos se sometan a procesos de limpieza y transformación antes de ser utilizados en el análisis."
  },
  {
    "objectID": "datos.html#lectura-de-datos",
    "href": "datos.html#lectura-de-datos",
    "title": "1  Datos",
    "section": "1.2 Lectura de Datos",
    "text": "1.2 Lectura de Datos\nUno de los objetivos principales de este capítulo es replicar fielmente los procesos de lectura, limpieza y estructura que realizan normalmente los analistas. Por lo tanto, se requiere tener bases de datos con la misma forma y estructura que las originales. Para este fin, se utilizará una base de datos llamada samples, que es una copia de la original, pero anonimizada aleatoriamente.Los datos originales fueron anomimizados mediante distribución aleatoria por columna, lo que impostibilita reconstruir la base original y a su vez los datos mantienen su estructura y tipología tal como se distribuyen los datos originales.\n\n\n\n\n\n\nDirectorio de Trabajo\n\n\n\nDefinir correctamente el directorio de trabajo en R, que corresponde al lugar o carpeta de origen de donde R va acceder a los diferentes archivos. (Ver Section B.5)\n\n\n\n1.2.1 Datos CSV\nUna forma común de almacenar tablas es mediante archivos de valores separados por comas (CSV). Estos archivos tienen una extensión .csv y se utilizan ampliamente para compartir datos porque son compatibles con muchos sistemas diferentes y ocupan relativamente poco espacio de almacenamiento. Una ventaja de usar archivos .csv es la disponibilidad de la función read.csv(), que está optimizada para importar archivos CSV y esta disponible por defeto en R base.\nLectura de Unitaria: A continuación procedermos a la lectura de uno de los archivos CSV. Recordar definir un directorio de trabajo que será el punto de partida donde se accederá a los diferentes archivos del proyecto. (Ver Section B.5)\n\n# 1. Definir Diferectorio de trabajo con setwd(\"\") o con Rstudio\n# 2. Lectura y asignar nombre de variables\n\npartes_1T_2015 &lt;- read.csv(\n  file = \"data/samples/Base Estadistica/CSV/partes_1er_trim_2015.csv\", \n  encoding = \"UTF-8\") \n\n# dim(partes_1T_2015)\n# str(partes_1T_2015)\n# head(partes_1T_2015)\n\n\n\n\n\n\n\nEncoding UTF-8\n\n\n\nSe agregó a la función read.csv() el parámetro encoding = \"UTF-8\" para procese correctamente las cadenas de textos con acentos o ñ propias del idioma español\n\n\nLectura de Secuencial: En este caso si todos los archivos que se van a leer se encuentran en la misma carpeta o directorio se recomienda que declare esa ruta en una variable en R y posteriormente genere la ruta completa adicionando solamente el nombre del archivo para esto usaremos la función paste0() para concatener cadenas de texto. (Ver Section C.1.2)\n\n# Declarar la ruta en una variable (considerar que finaliza con slash \"/\")\npath_csv &lt;-  \"data/samples/Base Estadistica/CSV/\"\n\n# Partes\n# Declarar la ruta del archivo + nombre\npartes_1T_2015 &lt;- read.csv(file =  paste0(path_csv, \"partes_1er_trim_2015.csv\"), \n                           encoding = \"UTF-8\")\npartes_2T_2015 &lt;- read.csv(file =  paste0(path_csv, \"partes_2do_trim_2015.csv\"), \n                           encoding = \"UTF-8\")\n\n\n# Participaciones\nparticp_1T_2015 &lt;- read.csv(\n  file =  paste0(path_csv, \"participantes_1er_trim_2015.csv\"),\n  encoding = \"UTF-8\")\nparticp_2T_2015 &lt;- read.csv(\n  file =  paste0(path_csv, \"participantes_2do_trim_2015.csv\"),\n  encoding = \"UTF-8\")\n\nUnir Bases: Uno de los objetivos puede ser unificar o consolidar bases del mismo tipo pero de diferentes periodos, se procede a su unidicación utilizando una de las formas más simples que es mediante la función rbind() que unir por filas (rows).\n\n\n\n\n\n\nCantidad de Columnnas\n\n\n\nPara que funione correctamente debemos estar seguros que las candidad de columnas de todos los dataframes que se van a unir deben ser idénticos.\n\n\n\n# Verificar si la cantidad de columnas son identicas\nncol(partes_1T_2015)\nncol(partes_2T_2015)\n\n\n# Unir Partes\npartes_2015 &lt;-  rbind(partes_1T_2015, partes_2T_2015)\ndim(partes_2015)\n\n\n# Unir Participaciones\nparticipaciones_2015 &lt;-  rbind(particp_1T_2015, particp_2T_2015)\ndim(participaciones_2015)\n\nGuardar Bases Conbinadas: Aquí hau que tener claro cual será carpeta de destino para nuestro caso en data/resultados/combinadas esta carpeta debe existir en el directorio. La función que se usará para guardar es write.csv().\n\npath_out = \"data/resultados/combinadas/\"\n\nfile_name_partes &lt;- \"partes_2015.csv\"\nwrite.csv(x = partes_2015, file = paste0(path_out, file_name_partes))\n\n\nfile_name_particp &lt;- \"participaciones_2015.csv\"\nwrite.csv(x = participaciones_2015, file = paste0(path_out, file_name_particp))\n\n\n\n1.2.2 Datos TXT\nOtra forma de almacenar tablas de datos es mediante archivos de texto plano con extensión .txt y que tambien se utilizan ampliamente para compartir datos porque son compatibles con muchos sistemas diferentes y ocupan relativamente poco espacio de almacenamiento. Utilizaremos la función read.delim() que también es de R base.\n\n\n\n\n\n\nDefinir el elemento separador\n\n\n\nUna consideración importante, para que R entienda que los datos que lee desde un archivo TXT corresponden a tablas de datos, hay que declarar que caracter es separador, en lcaso de los archivos de samples es \"\\t\" que representa tab. Puede variar de cada tipo de archivo.\n\n\nLectura de Unitaria: A continuación procedermos a la lectura de uno de los archivos CSV. Recordar definir un directorio de trabajo que será el punto de partida donde se accederá a los diferentes archivos del proyecto. (Ver Section B.5)\n\n# 1. Definir Diferectorio de trabajo con setwd(\"\") o con Rstudio\n# 2. Lectura y asignar nombre de variables\n\npartes_1T_2015_txt &lt;- read.delim(\n  file = \"data/samples/Base Estadistica/TXT/partes_1er_trim_2015.txt\",\n  header = TRUE, sep = \"\\t\", quote = \"\",  stringsAsFactors = FALSE, \n  encoding = \"UTF-8\") \n\ndim(partes_1T_2015_txt)\nstr(partes_1T_2015_txt)\nhead(partes_1T_2015_txt)\n\nLectura de Secuencial: En este caso si todos los archivos que se van a leer se encuentran en la misma carpeta o directorio se recomienda que declare esa ruta en una variable en R y posteriormente genere la ruta completa adicionando solamente el nombre del archivo para esto usaremos la función paste0() para concatener cadenas de texto.\n\n# Declarar la ruta en una variable (considerar que finaliza con slash \"/\")\npath_txt &lt;-  \"data/samples/Base Estadistica/TXT/\"\n\n# Partes\n# Declarar la ruta del archivo + nombre\npartes_1T_2015_txt &lt;- read.delim(\n  file =  paste0(path_txt, \"partes_1er_trim_2015.txt\"),\n  header = TRUE, sep = \"\\t\", quote = \"\",  stringsAsFactors = FALSE,\n  encoding = \"UTF-8\")\n\npartes_2T_2015_txt &lt;- read.delim(\n  file =  paste0(path_txt, \"partes_2do_trim_2015.txt\"),\n  header = TRUE, sep = \"\\t\", quote = \"\",  stringsAsFactors = FALSE,\n  encoding = \"UTF-8\")\n\n\n# Participaciones\nparticp_1T_2015_txt &lt;- read.delim(\n  file =  paste0(path_txt, \"participantes_1er_trim_2015.txt\"),\n  header = TRUE, sep = \"\\t\", quote = \"\",  stringsAsFactors = FALSE,\n  encoding = \"UTF-8\")\n\nparticp_2T_2015_txt &lt;- read.delim(\n  file =  paste0(path_txt, \"participantes_2do_trim_2015.txt\"),\n  header = TRUE, sep = \"\\t\", quote = \"\",  stringsAsFactors = FALSE,\n  encoding = \"UTF-8\")\n\nUnir Bases:\n\n# Verificar si la cantidad de columnas son identicas\ndim(partes_1T_2015_txt)\ndim(partes_2T_2015_txt)\n\n\n# Unir Partes\npartes_2015_txt &lt;-  rbind(partes_1T_2015_txt, partes_2T_2015_txt)\ndim(partes_2015_txt)\n\n\n# Unir Participaciones\nparticipaciones_2015_txt &lt;-  rbind(particp_1T_2015_txt, particp_2T_2015_txt)\ndim(participaciones_2015_txt)\n\nGuardar Bases Conbinadas: La función que se usará para guardar es write.table().\n\npath_out = \"data/resultados/combinadas/\"\n\nfile_name_partes &lt;- \"partes_2015.txt\"\nwrite.table(x = partes_2015_txt, file = paste0(path_out, file_name_partes),\n            sep = \"\\t\", na = \"\", quote = FALSE, eol = \"\\n\")\n\n\nfile_name_particp &lt;- \"participaciones_2015.txt\"\nwrite.table(x = participaciones_2015_txt, file = paste0(path_out, file_name_particp),\n            sep = \"\\t\", na = \"\", quote = FALSE, eol = \"\\n\")\n\n\n\n1.2.3 Datos Espaciales SHP\nLos objetos espaciales en R representan datos georreferenciados, lo que significa que están vinculados a una ubicación en el mundo real. Los objetos espaciales se pueden representar en mapas y gráficos, y se pueden analizar para identificar patrones y tendencias en los datos. Para nuestro casos, los objetos espaciales son tipo puntos que representan casos policiales en formato shapefile.Para su lectura y manipulación utilizaremos la librería sf (Simple Features for R).\n\n\n\n\n\n\nLibrería sf\n\n\n\nEl uso de sf nos facilitará la manipulación de datos espaciales tipo vectorial como puntos, polígonos o líneas, su característica principal es que se trabaja como si fuese una tabla y en una sola columna almacena las información espacial (geometry)\n\n\nLectura de Unitaria: A continuación procedermos a la lectura de uno de los archivos Shapefiles con su estensión .shp. Para la lectura utilizaremos la función st_read()\n\n# 1. Cargar Librería\nlibrary(sf)\n# 2. Lectura y asignar nombre de variables\n\ncasos_T1_2015 &lt;- st_read(dsn = \"data/samples/Base Geo/casos_2015_t1.shp\") \n\ndim(partes_1T_2015_txt)\nstr(partes_1T_2015_txt)\npartes_1T_2015_txt\n\nLectura de Secuencial: En este caso si todos los archivos que se van a leer se encuentran en la misma carpeta o directorio se recomienda que declare esa ruta en una variable en R y posteriormente genere la ruta completa adicionando solamente el nombre del archivo para esto usaremos la función paste0() para concatener cadenas de texto.\n\n# Declarar la ruta en una variable (considerar que finaliza con slash \"/\")\npath_txt &lt;-  \"data/samples/Base Geo/\"\n\n# Casps\n# unir la ruta del archivo + nombre\ncasos_T1_2015 &lt;- st_read(paste0(path_txt, \"casos_2015_t1.shp\"))\ncasos_T2_2015 &lt;- st_read(paste0(path_txt, \"casos_2015_t2.shp\"))\n\nUnir Bases:\nNo se pueden unir ya que no tienen las misma columnas\n\n# Verificar si la cantidad de columnas son identicas\ndim(casos_T1_2015)\ndim(casos_T2_2015)\n\n\n# Unir Partes\ncasos_2015 &lt;-  rbind(casos_T1_2015, casos_T2_2015)\n# Error in rbind.data.frame(...) : \n  # numbers of columns of arguments do not match\n\nSolución 1: Unir solo las colunas en común\n\n# encontrar la columnas en común\ncommon &lt;- intersect(colnames(casos_T1_2015), colnames(casos_T2_2015))\n\n# unir bases seleccionando solo als columnas en común\ncasos_2015_s1 &lt;- rbind(casos_T1_2015[common], casos_T2_2015[common])\ncasos_2015_s1\n\nSolución 2: Unir y en la base faltante rellena con NA usando dplyr::bind_rows()\n\nlibrary(dplyr)\n\ncasos_2015_s2 &lt;- bind_rows(casos_T1_2015, casos_T2_2015)\ncasos_2015_s2 \n\nGuardar Bases Conbinadas: La función que se usará para guardar es write.table().\n\npath_out = \"data/resultados/combinadas/\"\n\nfile_name_comun &lt;- \"casos_2015_comun.shp\"\nst_write(casos_2015_s1, paste0(path_out, file_name_comun), delete_dsn = T)\n\n\n\nfile_name_all &lt;- \"casos_2015_all.shp\"\nst_write(casos_2015_s2, paste0(path_out, file_name_all), delete_dsn = T)"
  },
  {
    "objectID": "datos.html#conclusión",
    "href": "datos.html#conclusión",
    "title": "1  Datos",
    "section": "1.3 Conclusión",
    "text": "1.3 Conclusión\nEn este capítulo se presentaron conocimientos esenciales para la lectura de datos tal como son adquiridos, con el objetivo de representar de manera fidedigna la etapa de pretratamiento que realizan los analistas. Además, se combinaron los diferentes periodos de cada tipo de datos y se guardaron de forma segura. En los siguientes capítulos se presentarán flujos de trabajo más eficientes y automatizados, pero por ahora es importante tener claridad sobre los pasos básicos."
  },
  {
    "objectID": "clean.html#introducción",
    "href": "clean.html#introducción",
    "title": "2  Limpieza",
    "section": "2.1 Introducción",
    "text": "2.1 Introducción\nEn este capítulo, se explorarán técnicas para la lectura de diferentes tipos de archivos y la transformación de datos. En particular, se abordará el proceso de limpieza de datos, que consiste en identificar y corregir errores, eliminar valores faltantes, tratar los datos duplicados y resolver cualquier inconsistencia en los datos."
  },
  {
    "objectID": "clean.html#cargar-librerías",
    "href": "clean.html#cargar-librerías",
    "title": "2  Limpieza",
    "section": "2.2 Cargar Librerías",
    "text": "2.2 Cargar Librerías\nEn primer lugar se procederá a cargar las librerías necesarias para realizar el tratamiento y transformaciones a los datos.\n\n## Manipulación de Tablas\nlibrary(dplyr)\nlibrary(tidyr)\n\n## Manipulación de Datos Espaciales\nlibrary(sf)"
  },
  {
    "objectID": "clean.html#lectura-y-unificación-de-bases",
    "href": "clean.html#lectura-y-unificación-de-bases",
    "title": "2  Limpieza",
    "section": "2.3 Lectura y Unificación de Bases",
    "text": "2.3 Lectura y Unificación de Bases\nLos datos se encuentran en formato RDS separados por y sin ningún tratamiento. Se procederá a revisar el contenido de los datos del año 2017 llamado Casos_2017.rds, para revisar la estructura de la base.\n\ndatos_2017 &lt;- readRDS(file = \"data/delitos/raw/Casos_2017.rds\")\nhead(datos_2017)\n\n\n\n\nSe puede observar que corresponde a 1.418.435 de casos policiales con información espacial tipo punto (Simple Features for R), además información temporal y divisiones administrativas.\nLas bases están separadas por año por lo tanto se van unificar para obtener un solo archivo, lo que facilitará hacer todas las transformaciones.\nPrimero se listarán todos los archivos que se encuentran en la carpeta\n\ndelitos_paths &lt;-  list.files(\"data/delitos/raw\", full.names = T)\n\nLa lectura se realizará usando la estuctura de blucle a través de un ciclo for() (ver Section D.2)\n\nfor(i in delitos_paths){\n  print( i )\n}\n\nConociendo los archivos se precederá a leer cada uno de ellos de forma secuencial\n\n\n\n\n\n\nLectura Secuencial\n\n\n\n\nSe declara una varible vacía en la cual se agregará cada base durante al iteración\nSe interará por cada uno de las rutas de los arhivos:\n2.1 Lectura readRDS().\n2.2 Combinar con rbind() en su defecto bind_rows().\n\n\n\nNotar que como las cantidad de columnas no son iguales arroja un error.\n\n# 1: Se declaara una varible vacía en la cual se agregará cada base durante al iteración\ndelitos_raw &lt;-  NULL\n\n# 2: Se interará por cada uno de las rutas de los arhivos:\n#   2.1 Lectura `readRDS()`\n#   2.2 Combinar con `robind()`\n\n\nfor(i in delitos_paths){\n  print( i )\n  base &lt;- readRDS(i)\n  delitos_raw &lt;-  rbind(delitos_raw, base)\n}\n\n# Show in New Window\n# [1] \"data/delitos/raw/Casos_2017.rds\"\n# [1] \"data/delitos/raw/Casos_2018.rds\"\n# [1] \"data/delitos/raw/Casos_2019.rds\"\n# Error in rbind.data.frame(...) :\n# numbers of columns of arguments do not match\n\nSolución utilizar la función bind_rows() de la librería dplyr\n\n# 1: Se declaara una varible vacía en la cual se agregará cada base durante al iteración\ndelitos_raw &lt;-  NULL\n\n# 2: Se interará por cada uno de las rutas de los arhivos:\n#   2.1 Lectura `readRDS()`\n#   2.2 Combinar con `robind()`\n\n\nfor(i in delitos_paths){\n  print( i )\n  base &lt;- readRDS(i)\n  delitos_raw &lt;-  dplyr::bind_rows(delitos_raw, base)\n}"
  },
  {
    "objectID": "clean.html#selección-de-variables",
    "href": "clean.html#selección-de-variables",
    "title": "2  Limpieza",
    "section": "2.4 Selección de variables",
    "text": "2.4 Selección de variables\nUna forma sencilla de selección de variables es definir previamente los nombres de columnas que se necesitará y después seleccionar con la función select_at()\n\n# selección de variables\ncols_names &lt;- c(\"DELITO\", \"GRUPO\", \"CLASIFICAC\", \n                \"CATEGORIA\",\"GRUPO_DELI\", \"GRUPO_INTE\",\n                \"FECHA_DEL\",  \"DIA\",  \"MES\", \"ANO\",\n                \"HORA_DEL_D\", \"HORA24\", \"BLOQUE\",\n                \"LUGAR\", \"geometry\")\n\n\ndelitos_raw &lt;- delitos_raw %&gt;% \n  select_at(.tbl = ., .vars = cols_names)"
  },
  {
    "objectID": "clean.html#eliminar-duplicados",
    "href": "clean.html#eliminar-duplicados",
    "title": "2  Limpieza",
    "section": "2.5 Eliminar Duplicados",
    "text": "2.5 Eliminar Duplicados\nEventualmente es posible que un sistema de adinistración de datos se generen registros duplicados, lo que puede afectar los posteriores análisis entonces es de importancia identificar cuando ocurre y eleminar los duplicados. A continuación se propone una estrategia para esto creando una variable ID compuesta por otras variables donde la probabilidad de que un evento se repita más de una vez sea casi imposble y los más problable que se encuentre en una situación duplicidad de registro.\nSe crea ID por cada registro considerando las variables de hora, fecha, delito_native, lon, lat. Como en nuestro caso la base de delitos en objeto espacial (Simple Features) se extraerá las columnas de latitud y longitud con la función sf2df() alojado en script de funciones generales (Section A.1).\nPrimero creamos una variable temporal de delitos con las columnas de interés:\n\ndel &lt;-  delitos_raw %&gt;% \n  sf2df() %&gt;% #variable temporal tipo df (sacar lon lat)\n  dplyr::select(HORA_DEL_D, FECHA_DEL, DELITO,  lon, lat)\n\nhead(del[,1:5])\n\nSe genera el ID para valores únicos\n\ndelitos_raw$ID &lt;- cumsum(!duplicated(del[,1:5]))\n\nSe extraen los duplicados (son los duplicados)\n\nduplicados &lt;- delitos_raw[duplicated(delitos_raw$ID), ]\n# head(duplicados)\n\nid_casos_dup &lt;- duplicados$ID\n# table(delitos$ID %in%id_casos_dup)\n\nEliminar duplicados\n\ndelitos_clean &lt;- delitos_raw[!duplicated(delitos_raw$ID), ]\n# dim(delitos_clean)\n# head(delitos_clean)"
  },
  {
    "objectID": "clean.html#imputar-datos-censales",
    "href": "clean.html#imputar-datos-censales",
    "title": "2  Limpieza",
    "section": "2.6 Imputar datos Censales",
    "text": "2.6 Imputar datos Censales\nA la información correspondiente a casos policiales se le va a imputar información de zonas censales (Instituto Nacional de Estadísticas) a través de una operación espacial llamada inteserct entre los polígonos de las zonas censales con los puntos de los casos policiales.\nLectura de Zonas censales\n\nzonas &lt;- readRDS(\"data/ine/zonas_urb_consolidadas.rds\") %&gt;% \n  st_transform(32719)\nhead(zonas)\n\nImputar infomación censal a delitos, para lo cual se utilizará la función add_info_intersects() que está en el script de funciones (Section A.2).\n\nzonas_inf_fil &lt;- zonas %&gt;% \n  dplyr::select(NOM_REGION, PROVINCIA, NOM_PROVIN,\n         COMUNA, NOM_COMUNA, URBANO,\n         DISTRITO, LOC_ZON, GEOCODIGO)\n\ndelitos_info &lt;- add_info_intersects(zonas_inf_fil, delitos_clean)\n# dim(delitos_info)\n# head(delitos_info)\n\nGuardar los resultados\n\nsaveRDS(delitos_info, \"data/delitos/delitos_all_info.rds\")"
  },
  {
    "objectID": "clean.html#categorizar-los-delitos",
    "href": "clean.html#categorizar-los-delitos",
    "title": "2  Limpieza",
    "section": "2.7 Categorizar los delitos",
    "text": "2.7 Categorizar los delitos\nConsiderando que en los casos policiales tiene una diversa tipificación de delitos se procede a categorizarlos en grupos similares.\nPara facilitar el proceso de clasificación a cada tipo de delito se le asignará una Sigla que se encuentra en una hoja de un archivo excel.\n\ndel_sigla &lt;- read.xlsx(\"data/excel/delito_native.xlsx\", \n                       sheet = \"delitos\") %&gt;% \n  mutate(DELITO = toupper(DELITO)) %&gt;% \n  rename(Sigla =CATEGORIA)\nhead(del_sigla)\n\n  Sigla                                               DELITO\n1    vi ABANDONO DE CÓNYUGE O DE PARIENTES ENFERMOS ART. 352\n2  &lt;NA&gt;                         ABANDONO DE DESTINO ART. 254\n3    vi                                    ABANDONO DE HOGAR\n4    vi                    ABANDONO DE NIÑOS ART. 346 AL 351\n5    hr                               ABIGEATO ART. 448 BIS.\n6  &lt;NA&gt;             ABORTO COMETIDO POR FACULTATIVO ART. 345\n\n\nLa lista de categorías se encuentra en el mismo archivo Excel\n\ncategorias &lt;- read.xlsx(\"data/excel/delito_native.xlsx\", \n                        sheet = \"categorias\")\n  \nhead(categorias)\n\n      Tipo Sigla             Categoria Barrios_Comerciales\n1 Públicos    dd    Desordenes y daños                   0\n2 Públicos    ci       Comercio ilegal                   1\n3 Públicos    hr         Hurtos, robos                   1\n4 Públicos    rm Robos vehiculos motor                   1\n5 Públicos    rv   Robos con violencia                   1\n6 Públicos    rl      Riñas y lesiones                   0\n  Organizacion_criminal\n1                     0\n2                     1\n3                     0\n4                     1\n5                     0\n6                     0\n\n\nCon la sigla previamente creada se procede a categorizar cada uno de los casos policiales\n\ndelitos_cat &lt;- left_join(delitos_info, del_sigla,\n                         by = \"DELITO\")\n# head(delitos_cat)\n\n\n\ndelitos_cat &lt;- left_join(delitos_cat, categorias, \n                         by = \"Sigla\")\n# head(delitos_cat)\n\nGuardar los resultados\n\nsaveRDS(delitos_cat, \"data/delitos/delitos_all_categ.rds\")\n\nComo resultado del proceso anterior quedan muchos casos policiales sin categoría asignada los cuales se proceden a eliminar.\n\n# #Descartar los NA en Categoria\ndelitos_cat_sigla &lt;- delitos_cat%&gt;%\n  filter(!is.na(Categoria))\n\n# head(delitos_cat)\n# dim(delitos_cat_sigla)\n\nGuardar los resultados\n\nsaveRDS(delitos_cat_sigla, \"data/delitos/delitos_only_cat.rds\")"
  },
  {
    "objectID": "clean.html#barrios-comerciales",
    "href": "clean.html#barrios-comerciales",
    "title": "2  Limpieza",
    "section": "2.8 Barrios Comerciales",
    "text": "2.8 Barrios Comerciales\nFinalmente se procede a filtrar aquellos casos policiales que sean considerados en el proyecto de valuación de barrios comerciales.\n\ndelitos_cat_bc_URB &lt;- delitos_cat%&gt;%\n  filter(Barrios_Comerciales == 1) \n\nGuardar los resultados\n\nsaveRDS(delitos_cat_bc_URB, \"data/delitos/delitos_eval_bcom_urb.rds\")"
  },
  {
    "objectID": "panel.html#introducción",
    "href": "panel.html#introducción",
    "title": "3  Datos de Panel",
    "section": "3.1 Introducción",
    "text": "3.1 Introducción\nEn estadística y econometría, el término de datos de panel se refiere a datos que combinan una dimensión temporal con otra transversal.\nUn conjunto de datos que recoge observaciones de un fenómeno a lo largo del tiempo se conoce como serie temporal. Dichos conjuntos de datos están ordenados y la información relevante respecto al fenómeno estudiado es la que proporciona su evolución en el tiempo. Un conjunto transversal de datos contiene observaciones sobre múltiples fenómenos en un momento determinado. En este caso, el orden de las observaciones es irrelevante.\nUn conjunto de datos de panel recoge observaciones sobre múltiples fenómenos a lo largo de determinados períodos. La dimensión temporal enriquece la estructura de los datos y es capaz de aportar información que no aparece en un único corte.\nPara nuestro caso los datos de panel serán la densidad de delitos por zona censal y el orden temporal será construido con el mes y el año eso es lo que se realizará a continuación."
  },
  {
    "objectID": "panel.html#sec-panel1",
    "href": "panel.html#sec-panel1",
    "title": "3  Datos de Panel",
    "section": "3.2 Cálculo de Total Delitos por Espacio y tiempo",
    "text": "3.2 Cálculo de Total Delitos por Espacio y tiempo\nEn este punto se procederá a crear tablas de cálculo de total casos policiales por espacio las zonas censales, mientras que tiempo las variables de mes y año.\n\n\n\n\n\nLectura de base de datos de casos policiales correspondientes al proyecto de Barrios comerciales por ende en zonas urbanas.\n\ndelitos_cat_bc_URB &lt;- readRDS(\"data/delitos/delitos_eval_bcom_urb.rds\")\n\n\n\n\nPrimeramente se debe extraer mes y año de la variable fecha para esto se hará uso de la librería Lubridate para manipulación de la variables temporales.\n\n# Agregar la variable mes\ndelitos_urb &lt;- delitos_cat_bc_URB %&gt;% \n  st_drop_geometry() %&gt;% \n  rename(fecha = FECHA_DEL) %&gt;% \n  mutate(mes = month(fecha),\n         anno = year(fecha)) %&gt;% \n  filter(!is.na(Categoria))\n\nhead(delitos_urb %&gt;%  select(fecha, mes, anno))\n\nA continuación se creará una tabla temporal que permitirá hacer una contabilidad de todos los delitos ocurridos por Zona censal, categoría, mes y año.\n\n# todos los delitos\ntab_del_all &lt;- delitos_urb%&gt;%\n  mutate(a_mes = paste0( anno, \"_\", sprintf(\"%02d\",mes))) %&gt;% \n  group_by(ZONA, Categoria, a_mes )%&gt;%\n  summarise(Cantidad = n(), .groups = \"keep\")\n\nhead(tab_del_all)\n\nA continuación se procede a generar el cálculo de la suma de todos los eventos policiales ocurridos por cada zona censal categoría mes y año utilizando la librería Tidyr con la función pivot_wider()\n\n\n\n\n\n\ntab_del_all_mes &lt;- tab_del_all%&gt;%\n  pivot_wider(names_from = a_mes, values_from = Cantidad, \n              names_prefix = \"a_\", values_fill = 0)%&gt;% \n  dplyr::select(ZONA, Categoria,sort(names(.)[3:ncol(.)]))\nhead(tab_del_all_mes)\n\n\n#guargar resultados\nwrite.xlsx(tab_del_all_mes,\n           \"data/tablas/tablas_del_mes/del_zonas_all.xlsx\", overwrite = T)\nsaveRDS(tab_del_all_mes, \"data/tablas/tablas_del_mes/del_zonas_all.rds\")"
  },
  {
    "objectID": "panel.html#sec-paneldensi",
    "href": "panel.html#sec-paneldensi",
    "title": "3  Datos de Panel",
    "section": "3.3 Cálculo de tablas de densidad casos policiales",
    "text": "3.3 Cálculo de tablas de densidad casos policiales\nLectura de Zonas Urbanas del INE, renomabramos la variable COD_INE_16 por ZONA, y seleccionamos además vaariable AREA.\n\nzonas &lt;- readRDS(\"data/ine/zonas_urb_consolidadas.rds\")\n\n\ninfo_zonas_base &lt;- zonas %&gt;%\n  st_drop_geometry() %&gt;% \n  dplyr::select(ZONA = COD_INE_16, AREA) %&gt;% \n  mutate(ZONA = as.character(ZONA))\n\nCalcular delitos anual y agregar área\n\ntab_del_all_mes &lt;- tab_del_all_mes %&gt;%\n  as.data.frame() %&gt;% #acelera el proceso\n  mutate(anual = rowSums(across(.cols = starts_with(\"a_\")))) %&gt;% \n  left_join(info_zonas_base, by = \"ZONA\")\n\nhead(tab_del_all_mes[, c(\"ZONA\", \"anual\", \"AREA\")])\n\nCalcular la densidad delitos por Hectárea (10000 metros) por cada mes y también anualmente\n\ntab_all_dens &lt;- tab_del_all_mes %&gt;% \n  mutate(across(starts_with(\"a_\"), ~ .x/(AREA/10000))) %&gt;% \n  mutate(dens_anual = anual / (AREA/10000))\n\n#visualización de las pimeras y ultimas columnas\nhead(tab_all_dens[,c(1:10, 77:77)])\n\nGuardar resultados\n\nwrite.xlsx(tab_all_dens, \n           \"data/tablas/tabla_dens_mes/del_dens_all.xlsx\",\n           overwrite = T)\n\nsaveRDS(tab_all_dens, \"data/tablas/tabla_dens_mes/del_dens_all.rds\")"
  },
  {
    "objectID": "panel.html#tablas-de-densidad-de-delitos-por-mes-2017-al-2022",
    "href": "panel.html#tablas-de-densidad-de-delitos-por-mes-2017-al-2022",
    "title": "3  Datos de Panel",
    "section": "3.4 Tablas de Densidad de Delitos por Mes (2017 al 2022)",
    "text": "3.4 Tablas de Densidad de Delitos por Mes (2017 al 2022)\nUnir Tablas de densidad de delitos por mes y anual con geometrías de zonas censales\n\n\n\n\ninfo_zonas_base &lt;- zonas %&gt;%\n  dplyr::select(ZONA = COD_INE_16, REGION, \n                NOM_REGION, COMUNA, NOM_COMUNA) %&gt;% \n  mutate(ZONA = as.character(ZONA))\n\ndel_dens_zonas &lt;- info_zonas_base %&gt;% \n  left_join(tab_all_dens, by =\"ZONA\") %&gt;% \n  filter(!is.na(ZONA))\nhead(del_dens_zonas[,1:10])\n\nSimple feature collection with 6 features and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 417007.9 ymin: 7731793 xmax: 467736.3 ymax: 7761723\nProjected CRS: WGS 84 / UTM zone 19S\n        ZONA REGION         NOM_REGION COMUNA   NOM_COMUNA\n1 1405011001     01 REGIÓN DE TARAPACÁ   1405         PICA\n2 1405011001     01 REGIÓN DE TARAPACÁ   1405         PICA\n3 1405011001     01 REGIÓN DE TARAPACÁ   1405         PICA\n4 1405011001     01 REGIÓN DE TARAPACÁ   1405         PICA\n5 1401011001     01 REGIÓN DE TARAPACÁ   1401 POZO ALMONTE\n6 1401011001     01 REGIÓN DE TARAPACÁ   1401 POZO ALMONTE\n                     Categoria   a_2017_01   a_2017_02 a_2017_03 a_2017_04\n1           Armas y homicidios 0.001071077 0.000000000         0         0\n2              Comercio ilegal 0.000000000 0.000000000         0         0\n3 Drogas y mercados criminales 0.006426460 0.001071077         0         0\n4                Hurtos, robos 0.000000000 0.000000000         0         0\n5           Armas y homicidios 0.005149346 0.000000000         0         0\n6              Comercio ilegal 0.000000000 0.000000000         0         0\n                        geometry\n1 MULTIPOLYGON (((467470.7 77...\n2 MULTIPOLYGON (((467470.7 77...\n3 MULTIPOLYGON (((467470.7 77...\n4 MULTIPOLYGON (((467470.7 77...\n5 MULTIPOLYGON (((417931.5 77...\n6 MULTIPOLYGON (((417931.5 77...\n\n\nGuardar resultados\n\nsaveRDS(del_dens_zonas, \"data/tablas/tabla_dens_mes/del_dens_zonas_pol.rds\")"
  },
  {
    "objectID": "panel.html#filtros-de-interés",
    "href": "panel.html#filtros-de-interés",
    "title": "3  Datos de Panel",
    "section": "3.5 Filtros de Interés",
    "text": "3.5 Filtros de Interés\nA continuación se realizará una serie de procedimientos para visualizar zonas de eventual interés, que eventualmente ustedes como analistas pueden modificar de acuerdo a sus objetivos. Como ejemplo se realizará una Selección de Zonas Censales con Mayor Densidad\nComezanremos conociendo los máximos y mínimos de densidad anual\n\nrange(del_dens_zonas$dens_anual, na.rm = T)\ndens_anual &lt;- del_dens_zonas$dens_anual\n# hist(dens_anual, breaks = 100)\nhist(dens_anual[dens_anual&gt;50], breaks = 100)\n\nDefinición de zonas que corresponde al porcentaje (5%) con mayor densidad\n\nn_porc &lt;- porc_df(del_dens_zonas, porcentaje = 5) # n corresponde a 5% datos\nn_porc\n\ndens_max &lt;- del_dens_zonas %&gt;% \n  slice_max(dens_anual, n = n_porc) # El 5 % de valores máximos\n\n# Densidades \n\n# mapview(dens_max, zcol = \"dens_anual\")\n\nConocer que región tiene las zonas con mayor concentración de delitos\n\nregiones_max &lt;- dens_max %&gt;% \n  st_drop_geometry() %&gt;% \n  group_by(REGION) %&gt;% \n  summarise(Cantidad = n()) %&gt;% \n  arrange(desc(Cantidad))\n\nregiones_max\n\nSelección de los 20 con mayor densidad de delitos de la región metropolitana.\n\nreg_dens_max &lt;- dens_max %&gt;% \n  filter(REGION == 13) %&gt;%\n  slice_max(dens_anual, n = 20) %&gt;% \n  filter(!is.na(dens_anual)) %&gt;% \n  mutate(dens_anual = round(dens_anual, 1))\n\nVisualizavión de Mapas con quiebres de Fisher\n\n# Crear Intervalos\nlibrary(classInt)\nbreaks_fisher &lt;- classIntervals(reg_dens_max$dens_anual,\n                                n = 10, style = \"fisher\", \n                                largeN = 10000L)\nmapview(reg_dens_max, \n        zcol = \"dens_anual\", \n        at = breaks_fisher$brks)\n\nVisualización de densidad máxima por alguna categoria\nAhora queremos conocer las 20 zonas censales con mayor densidad delitos por ejemplo “Hurtos, robos” en la región metrolitana de Santiago en todos los periodos.\n\nunique(del_dens_zonas$Categoria)\ncategoria_tipo &lt;-  \"Hurtos, robos\"  \n\ndens_max_cat &lt;- del_dens_zonas %&gt;% \n  filter(REGION == 13) %&gt;%\n  filter(Categoria==categoria_tipo)\n\nVisualización mapa\n\nbreaks_fisher &lt;- classIntervals(dens_max_cat$dens_anual,\n                                n = 10, style = \"fisher\", \n                                largeN = 10000L)\n# mapview(dens_max_cat, \n#         zcol = \"dens_anual\", \n#         at = breaks_fisher$brks)\n\nFiltraremos las 100 zonas censales con mayor densidad de “Hurtos, robos” en la región metropolitana\n\nregiones_max_cat &lt;- dens_max_cat %&gt;% \n  st_drop_geometry() %&gt;% \n  group_by(REGION) %&gt;% \n  summarise(Cantidad = n()) %&gt;% \n  arrange(desc(Cantidad))\n\nregiones_max_cat\n\n\nreg_dens_max_cat &lt;- dens_max_cat %&gt;% \n  filter(REGION == 13) %&gt;% \n  filter(!is.na(dens_anual))%&gt;% \n  slice_max(dens_anual, n = 100) \n\nmapview(reg_dens_max_cat, zcol = \"dens_anual\")"
  },
  {
    "objectID": "panel.html#sec-paneTiempo",
    "href": "panel.html#sec-paneTiempo",
    "title": "3  Datos de Panel",
    "section": "3.6 Densidades con Respecto al Tiempo",
    "text": "3.6 Densidades con Respecto al Tiempo\n\n\n\n\n\n\nts_info &lt;- tab_all_dens %&gt;% \n  dplyr::select(ZONA, Categoria, a_2017_01:a_2022_12) %&gt;% \n  pivot_longer(cols = a_2017_01:a_2022_12,\n               names_to = \"tiempo\", values_to = \"densidades\") %&gt;% \n  mutate(tiempo = gsub(\"a_\", \"\", tiempo),\n         tiempo = gsub(\"_\", \"-\", tiempo),\n         tiempo = ym(tiempo)) %&gt;% \n  filter(!is.na(ZONA))\n\n\nhead(ts_info)\n\n# A tibble: 6 × 4\n  ZONA        Categoria          tiempo     densidades\n  &lt;chr&gt;       &lt;chr&gt;              &lt;date&gt;          &lt;dbl&gt;\n1 10101011001 Armas y homicidios 2017-01-01     0     \n2 10101011001 Armas y homicidios 2017-02-01     0.139 \n3 10101011001 Armas y homicidios 2017-03-01     0.111 \n4 10101011001 Armas y homicidios 2017-04-01     0.0278\n5 10101011001 Armas y homicidios 2017-05-01     0     \n6 10101011001 Armas y homicidios 2017-06-01     0     \n\n\nGráficos\nVisualizaremos el comportamiento de una zona Censal en el tiempo, al azar.\n\nzona_id = c(\"13101021008\")\nts_zona &lt;- ts_info %&gt;% filter(ZONA == zona_id) \n  \n\npline &lt;- ggplot(data = ts_zona,\n            aes(x = tiempo, y = densidades,\n                group = Categoria, colour = Categoria)) + \n  geom_line(alpha = 0.8, linewidth = 0.8 ) +\n  xlab('Meses ') +\n  ylab('Densidades') +\n  theme_bw()\npline\n\n\n\n\nGráficos de Serie de Tiempo Todas las Categorías. Se utilizará la librería Plotly para hacer gráficos dinámicos\n\npline &lt;- ggplot(data = ts_info,\n            aes(x = tiempo, y = densidades,\n                group = Categoria, colour = Categoria)) + \n  geom_line(alpha = 0.4) +\n  xlab('Meses ') +\n  ylab('Densidades') +\n  theme_bw()\npline\n\n\n\n\n\npline &lt;- ggplot() + \n  geom_line(data = ts_info, aes(x = tiempo, y = densidades,\n                                colour = Categoria),\n            alpha = 0.4) +\n  xlab('Meses ') +\n  ylab('Densidades') +\n  theme_bw()+\n  facet_grid(Categoria ~ .) + \n  theme(legend.position = \"none\")\n# pline\npline\n\n\n\n# ggplotly(pline)\n\nGráficos sobre médidas de centralidad (4 Primeras Categorías)\n\nunique(ts_info$Categoria)\n\n[1] \"Armas y homicidios\"           \"Comercio ilegal\"             \n[3] \"Drogas y mercados criminales\" \"Hurtos, robos\"               \n\ndf_tidy_mean_1 &lt;- ts_info %&gt;%\n  filter(!is.na(densidades)) %&gt;%\n  filter(Categoria %in% unique(ts_info$Categoria)) %&gt;%\n  group_by(tiempo, Categoria) %&gt;%\n  summarise(n = n(),\n            mean = mean(densidades),\n            median = median(densidades),\n            sd = sd(densidades),\n            .groups = \"keep\") %&gt;%\n  mutate(sem = sd / sqrt(n - 1),\n         CI_lower = mean + qt((1-0.95)/2, n - 1) * sem,\n         CI_upper = mean - qt((1-0.95)/2, n - 1) * sem)\n\nmean_plot_1 &lt;- ggplot(df_tidy_mean_1, aes(x = tiempo, y = mean, color = Categoria)) +\n  geom_line(aes(x = tiempo, y = mean, color = Categoria)) +\n  geom_ribbon(\n    aes(ymin = CI_lower, ymax = CI_upper, fill = Categoria),\n    color = \"grey90\",\n    alpha = 0.2 )+\n  theme_bw()\nmean_plot_1\n\n\n\n# ggplotly(mean_plot_1)\n\nGráficos Desagregados\n\ncolor_list &lt;- viridis::viridis(length(unique(ts_info$Categoria)))\nmean_plot_1_solos &lt;- ggplot(df_tidy_mean_1, aes(x = tiempo, y = mean, color = Categoria)) +\n  geom_line(aes(x = tiempo, y = mean, color = Categoria)) +\n  geom_ribbon(\n    aes(ymin = CI_lower, ymax = CI_upper, fill = Categoria),\n    color = \"grey90\",\n    alpha = 0.2) +  \n  theme_bw()+\n  scale_fill_manual(values = color_list) +\n  scale_color_manual(values = color_list) +\n  facet_grid(Categoria ~ .) + \n  theme(legend.position = \"none\")\n\nmean_plot_1_solos\n\n\n\n# ggplotly(mean_plot_1_solos)"
  },
  {
    "objectID": "evo.html#introducción",
    "href": "evo.html#introducción",
    "title": "4  Evolución",
    "section": "4.1 Introducción",
    "text": "4.1 Introducción\nDentro del análisis criminológico espacial es fundamental conocer la evolución de los delitos en el tiempo. En esta sección, trabjará en la construcción y análisis de indicadores territoriales a nivel comunal de evolución criminal. El indicador para cumplir este propósito será uno que mida la variabilidad (positiva o negativa) normalizada de la cantidad delitos de las comunas en dos periodos de tiempo.\nAl comprender la evolución de los delitos en el tiempo, se busca tener una idea rápida y macro de la variabilidad de cada uno de los tipos de delitos en el país, como diagnóstico claro y preciso de la realidad en dos periodos de tiempo."
  },
  {
    "objectID": "evo.html#delitos-base",
    "href": "evo.html#delitos-base",
    "title": "4  Evolución",
    "section": "4.2 Delitos Base",
    "text": "4.2 Delitos Base\nCargar la librerías y funciones de uso general\n\nknitr::opts_chunk$set(echo = TRUE, eval = FALSE)\noptions(scipen = 999, warn=-1)\n\n#cargar Librerias\nsource(\"R/librerias.R\")\n# Cargar Funciones\nsource(\"R/funciones.R\")\n\nLectura de Insumos\nPara este resumen general utilizaremos los delitos dentro de la clsificación de Barrios Comerciales, entonces son urbanos. Puede ser con la base que ustedes estimen conveniente, pero debe tener la variable fecha.\n\ndelitos_cat_bc_URB &lt;- readRDS(\"data/delitos/delitos_eval_bcom_urb.rds\")\n\n\ndelitos_cat_bc_URB &lt;- readRDS(\"data_samples/delitos_eval_bcom_urb.rds\") \n\nGeneración de Tablas Resumen por día\nSeleccionamos la columnas que nos interesan y eliminamos la geometría.\n\ndel_all &lt;- delitos_cat_bc_URB %&gt;% \n  st_drop_geometry() %&gt;%\n  mutate(tiempo = (year(FECHA_DEL) * 100) + month(FECHA_DEL)) %&gt;% \n  select(COMUNA, tiempo, TIPO )\n\nTabla de cuenta de delitos diarios por comuna y tipología\n\ndelcomuna &lt;-  del_all %&gt;% \n  group_by(COMUNA, TIPO,  tiempo) %&gt;% \n  summarise(cantidad = n(), .groups = \"keep\")"
  },
  {
    "objectID": "evo.html#estadísticas",
    "href": "evo.html#estadísticas",
    "title": "4  Evolución",
    "section": "4.3 Estadísticas",
    "text": "4.3 Estadísticas\nEn esta etapa se realizarán la contabilidad de delitos por comunas y tipología, además se agregará el cálculo de una medida de dispersión como la varianza para aportar información. Queda abierta la posbilidad de agregar otras medidas estadísticas.\n\n4.3.1 Varianza\nLa varianza es una medida de dispersión que representa la variabilidad de una serie de datos respecto a su media, se denota como \\sigma^2.\n\n\n\nEjemplo de muestras de dos poblaciones con la misma media pero varianzas diferentes. La población roja tiene media 100 y varianza 100 (DE=10) mientras que la población azul tiene media 100 y varianza 2500 (DE=50).\n\n\n\n\nvarianzas &lt;- delcomuna %&gt;% \n  filter(!is.na(TIPO)) %&gt;% \n  group_by(COMUNA, TIPO) %&gt;% \n  summarise(varianza = sd(cantidad)^2,\n            cantidad = sum(cantidad),  .groups = \"keep\")\n\n# head(varianzas)\n\n\n\n4.3.2 Periodos\nEn esta etapa se van a definir los dos periodos que se compararán y así determinar la variabilidad. En este caso vamos analizar el segundo semestre del año 2017 versus el año 2022.\nPeriodo 1\n\np1_inicio &lt;- 201707\np1_final &lt;- 201707\n\nini &lt;- delcomuna %&gt;%\n  filter(tiempo  %in% p1_inicio:p1_final) %&gt;% \n  group_by(COMUNA, TIPO) %&gt;% \n  summarise(inicio = sum(cantidad),  .groups = \"keep\")\n\nPeriodo 2\n\np2_inicio &lt;- 202207\np2_final &lt;- 202212\n\nfin &lt;- delcomuna %&gt;%\n  filter(tiempo  %in% p2_inicio:p2_final) %&gt;% \n  group_by(COMUNA, TIPO) %&gt;% \n  summarise(fin = sum(cantidad),  .groups = \"keep\")\n\n\n\n4.3.3 Consolidación\nFinalmente se unen las tablas calculadas.\n\nadjvar &lt;- varianzas %&gt;% \n  left_join(ini, by = c(\"COMUNA\", \"TIPO\")) %&gt;% \n  left_join(fin, by = c(\"COMUNA\", \"TIPO\")) %&gt;% \n  mutate_if(.predicate = is.numeric,\n            .funs = function(x) ifelse(is.na(x), 0, x))"
  },
  {
    "objectID": "evo.html#indicador-de-variación",
    "href": "evo.html#indicador-de-variación",
    "title": "4  Evolución",
    "section": "4.4 Indicador de Variación",
    "text": "4.4 Indicador de Variación\nEn esta etapa se calcularà el indicador de la variación por cada tipo de delito y comuna. Corresponde a la diferencia entre los periodos (evolución) y se divide la suma de los dos períodos, para que el valor quede normalizado en valores entre 1 y -1.\n\nadjvar &lt;- adjvar %&gt;% \n  mutate(adjvar = (fin-inicio)/(fin+inicio)) %&gt;% \n  mutate_if(.predicate = is.numeric,\n            .funs = function(x) ifelse(is.na(x), 0, x))\n\nHistograma de la Variabilidad.\n\nlibrary(hrbrthemes)\np &lt;- adjvar %&gt;%\n  ggplot( aes(x=adjvar)) +\n    geom_histogram( binwidth=0.1, \n                    fill=\"#69b3a2\", color=\"#e9ecef\", alpha=0.9) +\n    ggtitle(\"Histograma de Variación Normalizada (muestra)\") +\n    theme_ipsum() +\n    theme(\n      plot.title = element_text(size=15)\n    )\np"
  },
  {
    "objectID": "evo.html#agregar-información-espacial",
    "href": "evo.html#agregar-información-espacial",
    "title": "4  Evolución",
    "section": "4.5 Agregar Información Espacial",
    "text": "4.5 Agregar Información Espacial\nFinalmente se agregará elos resultados del análisis a la la geometrías comunales de Chile para poder cartografias los resultados.\nSe de primeramente transformar las estructra de datos de formato largo a formato ancho, para que los valores de variabilidad de cada tipo de delito quede por columnas.\n\nvarianzas &lt;- adjvar %&gt;%\n  select(-varianza, -cantidad, -inicio, -fin) %&gt;% \n  mutate(TIPO = gsub(pattern = \" \", replacement = \"_\", x = TIPO)) %&gt;% \n  pivot_wider(names_from = TIPO,\n              values_from = c(adjvar), values_fill = 0)\n\nAgregar a la geometrias comunales del INE.\n\nComunas_Chile &lt;- readRDS(\"data/ine/Comunas_Chile.rds\")\n\n\ncomdel_dif &lt;- Comunas_Chile %&gt;% \n  left_join(varianzas, by  = \"COMUNA\") %&gt;% \n  mutate_if(.predicate = is.numeric,\n            .funs = function(x) ifelse(is.na(x), 0, x))\n\nGuardar Resultados en formato shapefiles\n\nst_write(comdel_dif, \"data/delitos/comdel_dif.shp\", delete_dsn = T)\n\n\n4.5.1 Revisión por tipología\nSelección de Región y Tipo de Delitos\n\n# grep(pattern = \"Desórdenes\", x = names(varianzas), value = T)\ntipo = \"Desórdenes\"\nregion = \"13\"\n\nr_eval = comdel_dif %&gt;% \n  filter(REGION == \"13\")\n\nHistograma\n\np &lt;- r_eval %&gt;%\n  st_drop_geometry() %&gt;% \n  ggplot( aes_string(x=tipo)) +\n    geom_histogram( binwidth=0.1,bins = 3, \n                    fill=\"#69b3a2\", color=\"#e9ecef\", alpha=0.9) +\n    ggtitle(\"Histograma de Variación Normalizada\") +\n    theme_ipsum() +\n    theme(\n      plot.title = element_text(size=15)\n    )\np\n\nVisualización Espacial\n\nmapview(r_eval, zcol = tipo)"
  },
  {
    "objectID": "tarea_1.html#antecedentes",
    "href": "tarea_1.html#antecedentes",
    "title": "Tarea 1",
    "section": "Antecedentes",
    "text": "Antecedentes\n\nFecha de entrega: 12 de Septiembre 2023\nFormato: Informe (docx, pdf) + Código (.R)\nIntegrantes: 3"
  },
  {
    "objectID": "tarea_1.html#instrucciones",
    "href": "tarea_1.html#instrucciones",
    "title": "Tarea 1",
    "section": "Instrucciones",
    "text": "Instrucciones\n\nParte 1: CSV\n\nLectura secuencial de archivos reales (no samples)\nUnir y Guardar\nVisualización de resultados (head, dim)\n\n\n\nParte 2: TXT\n\nLectura secuencial de archivos reales (no samples)\nUnir y Guardar\nVisualización de resultados (head, dim)\n\n\n\nParte 3: SHP\n\nLectura secuencial de archivos reales (no samples)\nUnir (dos soluciones y justificar la mejor opción) y Guardarlos\nVisualización de resultados (head, dim)"
  },
  {
    "objectID": "tarea_2.html#antecedentes",
    "href": "tarea_2.html#antecedentes",
    "title": "Tarea 2",
    "section": "Antecedentes",
    "text": "Antecedentes\n\nFecha de entrega: 26 de Septiembre 2023\nFormato: Informe (docx, pdf) + Código (.R)\nIntegrantes: 3"
  },
  {
    "objectID": "tarea_2.html#instrucciones",
    "href": "tarea_2.html#instrucciones",
    "title": "Tarea 2",
    "section": "Instrucciones",
    "text": "Instrucciones\nSiguiendo como referencia el capítulo de “Limpieza” (Chapter 2) siga las siguiente instrucciones\n\nParte 1: Lectura y Unificación de Bases\n\nLeer todas las bases de datos anuales que se encuentra en data/delitos/raw/ unificarlos a través de un cilo iterativo for.\nSeleccionar las variables c(\"DELITO\", \"FECHA_DEL\", \"HORA_DEL_D\", \"BLOQUE\")\nEliminar duplicados\n\n\n\nParte 2: Imputación de Información Censal\nA cada caso policial por su ubicación geográfica imputarle información sociodemográfica de la zona censal correspondiente. Finalmente guardar los datos en .rds.\n\n\n\n\n\n\nFunción add_info_intersects()\n\n\n\nHacer uso de la función add_info_intersects() ver Section A.2\n\n\n\n\nParte 3: Categorización de Delitos\nCon los datos consildados de las etapas anteriores, se deben categorizar los delitos, haciendo uso de arvhivo excel que contiene las siglas y categorias. Previamente se debe agregar una nueva agrupación de delitos que ustedes estimen conveniente, de acuerdo a un hipotético campo de investigación. Finalmente se debe filtrar los casos policiales asociados a su categoría de investigación.\n\n\n\n\n\n\ndelito_native.xlsx\n\n\n\nPara agregar una nueva agrupación de delitos se debe modificar el archivo excel data/excel/delito_native.xlsx, hoja categorias y agregar una nueva columna."
  },
  {
    "objectID": "tarea_3.html#antecedentes",
    "href": "tarea_3.html#antecedentes",
    "title": "Tarea 3",
    "section": "Antecedentes",
    "text": "Antecedentes\n\nFecha de entrega: 10 de Octubre 2023\nFormato: Informe (docx, pdf) + Código (.R)\nIntegrantes: 3 o 4"
  },
  {
    "objectID": "tarea_3.html#instrucciones",
    "href": "tarea_3.html#instrucciones",
    "title": "Tarea 3",
    "section": "Instrucciones",
    "text": "Instrucciones\nSiguiendo como referencia el capítulo de “Datos Panel” (Chapter 3) siga las siguiente instrucciones:\n\nParte 1: Transformación de Datos (50%)\n\nUtilizando los datos producto de la caracterización de Delitos de la tarea 2, donde se debía crear una nueva categorización (no usar Barrios_Comerciales) calcular la cantidad de delitos por mes y estructurarlos longitudinalmente con pivot_wider como se hizo en la Section 3.2.\nCalcular la densidad de delitos por zona censal (Section 3.3)\nImputar los resultados de densidad de delitos a la zonas censalesy guardar los resultados.\n\n\n\nParte 2: Consultas (25%)\n\nDe la base de densidad de delitos por zona censal creada, seleccionar una región de región de estudio y una categoría.\nFiltrar las 10 Zonas censales que presenten mayor densidad de delitos globales (todos los meses y años)\nGenere tabla y una visualización espacial con mapview\n\n\n\nParte 3: Visualizaciones (25%)\n\nUtilizando los datos generados en la parte 1 de esta tarea, convertirlos en formato largo (pivot_longer) para generar visulizaciones.\nFiltrar por la misma región de estudio y realizar cálculos de medidas de centralidad, finalmente generar un gráfico temporal del comportamiento de todas la categorías."
  },
  {
    "objectID": "trabajo_final.html#antecedentes",
    "href": "trabajo_final.html#antecedentes",
    "title": "Trabajo Final",
    "section": "Antecedentes",
    "text": "Antecedentes\n\nFecha de Presentación: 27 de Octubre 2023\nFecha de entrega Informe: 27 de Octubre 2023\nFormato Informe (docx, pdf) + Código (.R)\nIntegrantes: 3 o 4\nDatos: compartir_SPD -&gt; data -&gt; datos_trabajo_final"
  },
  {
    "objectID": "trabajo_final.html#instrucciones",
    "href": "trabajo_final.html#instrucciones",
    "title": "Trabajo Final",
    "section": "Instrucciones",
    "text": "Instrucciones\n\nPlantee una pregunta de investigación referente a la evolución y distribución de un fenómeno delictual que sea de particular interés para usted. Ej: ¿Cómo ha evolucionado el crimen organizado en Chile y en qué ciudades ha tenido mayor impacto?. Explique en qué consiste el fenómeno escogido y porqué es interesante analizarlo.\nEscoja un conjunto de tipos de delitos (mínimo 3) que tenga relación con la pregunta planteada y explique en qué consiste esta relación. Ej: De una parte, Drogas y Trata de Personas, porque son delitos lucrativos que proveen la principal fuente de ingresos al crimen organizado en Chile. De otra parte, Armas, Homicidios y Secuestros, porque son crímenes relacionados con la disputa territorial y el fortalecimiento del poder de coerción de organizaciones criminales.\nIdentifique las comunas de Chile que presenten mayor aumento en los delitos seleccionados, entre el 2° semestre de 2017 y el 2° de 2022, mediante un análisis cartográfico de variación normalizada de casos policiales (detenciones + denuncias). Se recomienda usar simbología de puntos seleccionando solamente las comunas con variación extrema.\nEscoja una región particularmente afectada por el fenómeno delictual escogido y fundamente esta elección. Realice un análisis cartográfico comparativo de las comunas en la región, usando la variación normalizada de casos policiales. Se recomienda usar simbología de polígonos con escalas de color.\nAnalice la evolución de los tipos de delitos escogidos en el período 2012-2022, comparando para cada tipo las tendencias de Detenciones Policiales, Denuncias Policiales y Registros del sistema Denuncia Seguro. Realice este análisis a escala de las comunas más relevantes para su pregunta de investigación, de la región escogida y del total país. ¿Qué se puede inferir de las diferencias entre las distintas fuentes estadísticas? ¿Parece probable que existan sesgos o diferencias importantes de cifras negras entre ellas? ¿Qué se puede inferir de las diferencias o similitud de tendencias en las distintas escalas analizadas?"
  },
  {
    "objectID": "references.html#bibliográficas",
    "href": "references.html#bibliográficas",
    "title": "References",
    "section": "Bibliográficas",
    "text": "Bibliográficas\nEn proceso."
  },
  {
    "objectID": "references.html#enlaces-de-apoyo",
    "href": "references.html#enlaces-de-apoyo",
    "title": "References",
    "section": "Enlaces de Apoyo",
    "text": "Enlaces de Apoyo\n\nR para Ciencia de Datos\nRStudio para Estadística Descriptiva en Ciencias Sociales\nhttps://bookdown.org/jboscomendoza/r-principiantes4/estructuras-de-control.html"
  },
  {
    "objectID": "crime_f.html#sec-fnc_df2sf",
    "href": "crime_f.html#sec-fnc_df2sf",
    "title": "Appendix A — Funciones Generales",
    "section": "A.1 Dataframe to SF Object",
    "text": "A.1 Dataframe to SF Object\nConvertir DataFrame con columnas de latitud y longitud a un objeto espacial llamado simple feature además se le puede asignar un sistema de referencia de coordenadas.\n\n# dataframe a sf\ndf2sf &lt;- function(df, lon =\"lon\", lat =\"lat\", crs_base = 4326) {\n  sf_object &lt;- df %&gt;%\n    dplyr::filter(!is.na(lon)|!is.na(lat)) %&gt;%\n    sf::st_as_sf(coords = c(lon, lat),\n                 crs = crs_base, agr = \"constant\")\n  return(sf_object)\n}\n\nAl inverso esta función permite convertir de un objeto espacial tipo puntos a una tabla de datos a la cual se le agregará latitud y longitud como columnas.\n\n# sf to dataframe\nsf2df &lt;- function(sf_points){\n  df &lt;- sfheaders::sf_to_df( sf_points, fill = TRUE ) %&gt;% \n    rename(lon = x, lat = y)\n  return(df)\n}"
  },
  {
    "objectID": "crime_f.html#sec-fnc_addIntersect",
    "href": "crime_f.html#sec-fnc_addIntersect",
    "title": "Appendix A — Funciones Generales",
    "section": "A.2 Imputar datos por intersect",
    "text": "A.2 Imputar datos por intersect\n\nadd_info_intersects &lt;-  function(pol_info, sf_data){\n# versión eficiente de intersects\n  id_int &lt;- sapply(st_intersects(sf_data, pol_info), \n                   function(z) if (length(z)==0) NA_integer_ else z[1])\n  \n  pol_info &lt;- pol_info %&gt;% \n    mutate(id = 1:nrow(.)) %&gt;% \n    st_drop_geometry()\n  \n  resultados &lt;- sf_data%&gt;%\n    mutate(id = id_int) %&gt;%\n    left_join(pol_info, by =\"id\")\n  return(resultados)\n  \n}"
  },
  {
    "objectID": "crime_f.html#tablas-resumen",
    "href": "crime_f.html#tablas-resumen",
    "title": "Appendix A — Funciones Generales",
    "section": "A.3 Tablas Resumen",
    "text": "A.3 Tablas Resumen\nCrea un resumen estadístico por cada una de las comunes columnas del data frame\n\nresumen_base &lt;- function(base, name_base, n_samples = 5){ \n  smp &lt;- sample(nrow(base), size = n_samples, replace = F)\n  res &lt;- NULL\n  for(i in 1:ncol(base)){\n    r &lt;- data.frame(\n      col_name = as.character(names(base)[i]),\n      # col_name_cor =  names(janitor::clean_names(base))[i],\n      n_rows = nrow(base),\n      n_unique = length(unique(base[,i])),\n      n_NA = sum(is.na(base[,i])),\n      min = round(min(base[,i],  na.rm = T), 3),\n      max = round(max(base[,i],  na.rm = T), 3),\n      mean = round(mean(base[,i],  na.rm = T), 3),\n      sample1 = as.character(base[smp[1],i]),\n      sample2 = as.character(base[smp[2],i]),\n      sample3 = as.character(base[smp[3],i]),\n      sample4 = as.character(base[smp[4],i]),\n      sample5 = as.character(base[smp[5],i])\n    )\n    r &lt;- r %&gt;%\n      mutate(base_name = name_base, \n             porc_NA = round((n_NA / nrow(base)) * 100, 2),\n             col_name = gsub(pattern = \"\\\\.\", replacement = \" \", x = col_name),# puntos -&gt; espacios\n      )%&gt;%\n      dplyr::select(base_name, col_name,  n_rows, n_unique, n_NA, porc_NA, everything())\n    \n    res &lt;- rbind(res, r)\n  }\n  return(res)\n  \n}"
  },
  {
    "objectID": "crime_f.html#funciones-de-uso-general",
    "href": "crime_f.html#funciones-de-uso-general",
    "title": "Appendix A — Funciones Generales",
    "section": "A.4 Funciones de uso general",
    "text": "A.4 Funciones de uso general\n\n# Si no existe directorio lo crea\nmake_dir &lt;- function(path){\n  if (!dir.exists(path)) dir.create(path, recursive = TRUE)\n}\n\n# transformar -999 a NA\nfix_missing &lt;- function(x) {\n  if(is.numeric(x)){\n    x[x == -999] &lt;- NA\n    \n  }\n  return(x)\n}\n\n\n# transformar NA a 0\nfix_NA_0 &lt;- function(x) {\n  x[is.na(x)] &lt;- 0\n  return(x)\n}\n\n\n\n# Reeplaza puntos pomas\npto_por_coma &lt;- function(x){\n  format(x, big.mark = \".\", decimal.mark = \",\" ,\n         scientific = FALSE)\n  \n}\n\nsimpleCap &lt;- function(x) {\n  s &lt;- strsplit(x, \" \")[[1]]\n  paste(toupper(substring(s, 1, 1)), substring(s, 2),\n        sep = \"\", collapse = \" \")\n}\n\nsf_toupper &lt;-  function(sf_object){\n  names(sf_object)[1:(ncol(sf_object)-1)] &lt;- toupper(names(sf_object)[1:(ncol(sf_object)-1)])\n  return(sf_object)\n}\n\n# función paara saber catidad de acuerdo un porcentaje\nporc_df &lt;- function(dataframe, porcentaje){\n  if(porcentaje&gt;100){\n    stop(\"Porcentaje NO puede ser mayor que 100\")\n  }else{\n    num &lt;- round(nrow(dataframe)*(porcentaje/100))\n  }\n  return(num)\n}"
  },
  {
    "objectID": "crime_f.html#cuenta-duplicados-por-columna",
    "href": "crime_f.html#cuenta-duplicados-por-columna",
    "title": "Appendix A — Funciones Generales",
    "section": "A.5 Cuenta duplicados por columna",
    "text": "A.5 Cuenta duplicados por columna\n\nduplicados &lt;- function(file, columna) {\n  if (columna == \"geometry\") {\n    col &lt;- file %&gt;% dplyr::select(all_of(columna))\n  } else{\n    col &lt;-\n      file %&gt;% st_drop_geometry() %&gt;% dplyr::select(all_of(columna))\n  }\n  \n  d &lt;- col %&gt;% duplicated() %&gt;% sum()\n  return(d)\n}"
  },
  {
    "objectID": "crime_f.html#leer-delitos-rds-por-año",
    "href": "crime_f.html#leer-delitos-rds-por-año",
    "title": "Appendix A — Funciones Generales",
    "section": "A.6 Leer delitos rds por año",
    "text": "A.6 Leer delitos rds por año\n\nread_delitos &lt;-\n  function(path_data = \"data/delitos/delitos_base/\", year) {\n    delitos &lt;- readRDS(paste0(path_data, \"delitos_\", year, \".rds\"))\n    return(delitos)\n  }"
  },
  {
    "objectID": "crime_f.html#función-seleccionar-muestra-n",
    "href": "crime_f.html#función-seleccionar-muestra-n",
    "title": "Appendix A — Funciones Generales",
    "section": "A.7 Función seleccionar muestra n",
    "text": "A.7 Función seleccionar muestra n\n\nmuestra_n &lt;-  function(df, n, random = F){\n  if(isTRUE(random)){\n    x &lt;- dplyr::slice_sample(df, n = n, replace = F)\n  }else{\n    x &lt;- df[1:n]\n  }\n  return(x)\n}"
  },
  {
    "objectID": "crime_f.html#función-seleccionar-muestra-por-fracción",
    "href": "crime_f.html#función-seleccionar-muestra-por-fracción",
    "title": "Appendix A — Funciones Generales",
    "section": "A.8 Función seleccionar muestra por fracción",
    "text": "A.8 Función seleccionar muestra por fracción\n\nmuestra_frac &lt;-  function(df, prop){\n    x &lt;- dplyr::slice_sample(df, prop = prop, replace = F)\n  return(x)\n}"
  },
  {
    "objectID": "crime_f.html#muestreo-aleatorio",
    "href": "crime_f.html#muestreo-aleatorio",
    "title": "Appendix A — Funciones Generales",
    "section": "A.9 Muestreo Aleatorio",
    "text": "A.9 Muestreo Aleatorio\nFunción que cambia orden de elementos en un vector, en el caso de aplicación este vector será una columna.\n\n# valores aleatios por columna\n\ngenerar_datos_aleatorios &lt;- function(columna) {\n  # Obtener la longitud de la columna\n  longitud &lt;- length(columna)\n  # Generar datos aleatorios de la misma longitud\n  datos_aleatorios &lt;- sample(columna, longitud)\n  return(datos_aleatorios)\n}\n\nA continuación se presentan una serie de funciones de lectura de archivos en diferentes formatos, que aposteriormente noniminza aleatoriamente cada columna utilizando la función generar_datos_aleatorios(), luego toma una muestra de datos y finalmente guarda los resultados. Lo anterior, se crearon funciones para datos tipo csv, txt y shapefile.\n\nsamples_csv &lt;- function(path_in, path_out, file_name, n_samples){\n  \n  print(\"Lectura\")\n  tabla_anonima &lt;- read.csv(file = paste0(path_in, file_name),\n                            stringsAsFactors = FALSE) \n  \n  \n  print(\"Revolviendo datos por columna\")\n  tabla_anonima  &lt;- tabla_anonima%&gt;%\n    mutate_all(~ generar_datos_aleatorios(.))%&gt;% \n    sample_n(size = n_samples, replace = F) \n  \n  print(\"guardando\")\n  write.csv(x = tabla_anonima, file = paste0(path_out, file_name))\n  return(tabla_anonima)\n}\n\n\nsamples_txt &lt;- function(path_in, path_out, file_name, n_samples, \n                        header = TRUE, sep = \"\\t\"){\n  \n  print(\"Lectura\")\n  tabla_anonima &lt;- read.delim(file = paste0(path_in, file_name),\n                              sep = sep, header = header, \n                              quote = \"\", \n                              stringsAsFactors = FALSE) \n  \n  print(\"Revolviendo datos por columna\")\n  tabla_sampled  &lt;- tabla_anonima%&gt;%\n    mutate_all(~ generar_datos_aleatorios(.))%&gt;% \n    sample_n(size = n_samples, replace = F) \n  \n  print(\"guardando\")\n  write.table(x = tabla_sampled, file = paste0(path_out, file_name), \n               sep = sep, na = \"\", quote = FALSE, eol = \"\\n\")\n  return(tabla_sampled)\n}\n\n\nsamples_shp &lt;- function(path_in, path_out, file_name, n_samples){\n  \n  print(\"Lectura\")\n  tabla_sf &lt;- st_read(paste0(path_in, file_name)) \n  \n  print(\"Revolviendo datos por columna\")\n  tabla_sf_anomina  &lt;- tabla_sf%&gt;%\n    mutate_all(~ generar_datos_aleatorios(.))%&gt;% \n    sample_n(size = n_samples, replace = F) \n  \n  print(\"guardando\")\n  st_write(tabla_sf_anomina, paste0(path_out, file_name), delete_dsn =T)\n  return(tabla_sf_anomina)\n}"
  },
  {
    "objectID": "r_project.html#qué-es-r-project",
    "href": "r_project.html#qué-es-r-project",
    "title": "Appendix B — R Project",
    "section": "B.1 ¿Qué es R Project?",
    "text": "B.1 ¿Qué es R Project?\nR es un lenguaje programación multiparadigma (procedural, imperativo, orientado a objetos y funcional) enfocado a aplicaciones estadísticas. Por estadísticas se debe entender también los campos de estudio que se basan o las utilizan como económía, finanzas, ciencia de datos, machine learning, etc.\n\nB.1.1 Ventajas de Utilizar R Project\n1. R es un software libre\n\nLa libertad de ejecutar el programa como desee y con cualquier propósito\nEstudiar el funcionamiento del programa y adaptarlo a sus necesidades.\nRescribir copias para ayudar a los demás.\nManejar el programa y publicar las mejorar, de manera que toda comunidad se beneficie.\n\n2. R es multiplataforma\n\nR funciona en Mac, Windows y en numerosos sistemas UNIX. Esto significa que cualquier persona puede trabajar con tus datos, figuras, análisis y más importante aún usar tus instrucciones (también conocido como scripts o código) para generar las figuras y el análisis. Así que cualquier persona, y en cualquier lugar del mundo, con acceso a cualquier SO puede usar R sin ninguna licencia.\n\n3. R es de código abierto\n\nExiste una gran comunidad de voluntarios trabajando para mejorarlo, lo cual permite ser moldeado y dirigido a cuestiones específicas. Creando así programas y paquetes que funcionen en el entorno R. Programas tales como R-studio, Java GUI for R, R- commander, RKWard, entre otros, y con más de 18000 paquetes indexado en CRAN, Biocoductor, GitHub y R-Forge.\n\n4. Todo dentro de un mismo entorno\n\nR remplaza la combinación de varios programas para el proceso de análisis de datos, por ejemplo Excel, ArcGis, QGis, SigmaPlot, entre otros. Esto no solo resulta en el alto costo de las licencias de múltiples programas, si no también, en la gran cantidad de archivos con diferentes formatos que no podrían leer otros programas. En cambio con solo utilizar R, puedes realizar todo el análisis de datos e inclusive leer archivos de diferentes formatos.\n\n\n\nB.1.2 Desventajas de utilizar R\n\nR tiene una vasta documentación de ayuda, descripción de paquetes y de funciones, que es difícil encontrar información específica en un momento dado.\nLos mensajes de error que R nos muestra, no es específica sobre los fallos que estamos realizando y solo un usuario con cierta experiencia en el uso de R puede saberlo."
  },
  {
    "objectID": "r_project.html#instalación-de-r-project",
    "href": "r_project.html#instalación-de-r-project",
    "title": "Appendix B — R Project",
    "section": "B.2 Instalación de R Project",
    "text": "B.2 Instalación de R Project\n\nB.2.1 Instalación de R Project\nPrimero se debe instalar R Project desde su sitio oficial (https://cran.r-project.org/bin/windows/base/), se ejecuta el instalador que se descargó depende del sistema operativo del PC, como se muestra en las siguientes figuras:\n\n\n\nB.2.2 Instalación de R para Windows\n\n\n\n\n\nB.2.3 Instalar Rtools (solo Sistema Operativo Windows)\n\n\n\n\n\n\n\n\nB.2.4 Instalación de R para Mac\n\n\n\nR Project Ejecutándose"
  },
  {
    "objectID": "r_project.html#instalación-de-rstudio",
    "href": "r_project.html#instalación-de-rstudio",
    "title": "Appendix B — R Project",
    "section": "B.3 Instalación de RStudio",
    "text": "B.3 Instalación de RStudio\nSe recomienta instalar Rstudio, que es Interfaz de Usuario de R Project, desde su sitio web oficial, el cual permite acceder con mayor facilidad a sus funciones y potencialidades de R.\n\n\n\n\n\n\n\n\n\nB.3.1 RStudio Cloud\nRStudio Cloud es una versión ligera del IDE RStudio alojada en la la nube que permite a cualquiera hacer, compartir, enseñar y aprender Ciencias de Datos Online. Tiene una versión gratuita limitada.\n\nB.3.1.1 Características:\n\nAnalyze your data using the RStudio IDE, directly from your browser.\nShare projects with your team, class, workshop or the world.\nTeach data science with R to your students or colleagues.\nLearn data science in an instructor-led environment or with interactive tutorials."
  },
  {
    "objectID": "r_project.html#instalar-librerías",
    "href": "r_project.html#instalar-librerías",
    "title": "Appendix B — R Project",
    "section": "B.4 Instalar Librerías",
    "text": "B.4 Instalar Librerías\n\nB.4.1 Librerías en R\nLas librerías o paquetes en R corresponden a una colección de funciones encapsuladas y diseñadas para atender una tarea específica. Por ejemplo, hay paquetes para trabajo visualización geoespacial, análisis psicométricos, mineria de datos, interacción con servicios de internet y muchas otras cosas más.\nEstos paquetes se encuentran alojados principalmente en CRAN (Comprehensive R Archive Network), así que pasan por un control riguroso antes de estar disponibles para su uso generalizado, al día de hoy (29.11.2021) existen 18498 paquetes disponibles. En el siguiente enlace se deja una lista de temas y sus librerías asociadas disponibles, con una breve descripción (enlace)\nAunque las versiones de prueba de una librería pueden estar disponible en Github (Respositorio de Control de Versiones) de cada autor.\n\n\nB.4.2 Ejemplo de Instalación de Librerías desde R\nPodemos instalar paquetes usando la función install.packages(), dando como argumento el nombre del paquete que deseamos instalar, entre comillas.\nPara instalar librerías se puede hacer directamente desde la consola de RStudio, por ejemplo:\n\ninstall.packages(\"dplyr\") # Se puede instalar más de una librería a la vez\n\n\n\nB.4.3 Ejemplo de Instalación de Librerías desde Rstudio\nTambién se pude instalar librerías del Panel “Packages”\n\n\n\nY por último se puede instalar desde Pestaña “Tools” -&gt; “Install Packages”:"
  },
  {
    "objectID": "r_project.html#sec-wd",
    "href": "r_project.html#sec-wd",
    "title": "Appendix B — R Project",
    "section": "B.5 Definición de Directorios de Trabajos",
    "text": "B.5 Definición de Directorios de Trabajos\nDefinir directorio de Trabajo con RStudio\n\n\n\n\n\n\nDefinir Directorio de Trabajo con una función\n\nsetwd(\"~/OneDrive - Universidad Adolfo Ibanez/FONDECYT/capacitacion_SPD\")\n\nConsultar Directorio de Trabajo\n\ngetwd()\n\n[1] \"/Users/denisberroeta/Library/CloudStorage/OneDrive-UniversidadAdolfoIbanez/FONDECYT/CURSO_SPD/book_SPD\""
  },
  {
    "objectID": "r_project.html#referencias",
    "href": "r_project.html#referencias",
    "title": "Appendix B — R Project",
    "section": "B.6 Referencias:",
    "text": "B.6 Referencias:\n\nR para Ciencia de Datos\nRStudio para Estadística Descriptiva en Ciencias Sociales\nhttps://bookdown.org/jboscomendoza/r-principiantes4/estructuras-de-control.html"
  },
  {
    "objectID": "variables.html#tipos-de-objetos-en-r",
    "href": "variables.html#tipos-de-objetos-en-r",
    "title": "Appendix C — Variables en R",
    "section": "C.1 Tipos de Objetos en R",
    "text": "C.1 Tipos de Objetos en R\nLos Datos en R se pueden clasificar por su dimensiones y los tipos de Datos que permiten almacenar, como se muestra en la siguiente tabla:\n\n\n\nDimensiones\nHomogéneos\nHeterogéneos\n\n\n\n\n1d\nAtomic vector\nList\n\n\n2d\nMatrix\nData frame\n\n\nnd\nArray\n\n\n\n\nFuente: http://adv-r.had.co.nz/Data-structures.html\nR nos permite definir variables que pueden ser luego usadas en las distintas operaciones. El lenguaje no solo permite definir escalares (variable de un numero), si no también variables que sean un conjunto de numero o caracteres ordenados.\n\nC.1.1 Variables Numéricas\n\n# La asignación en R son válidos 2 métodos '&lt;-' o '='\nx &lt;- 7 # Definir variable (escalar) x que sea igual a 7\nx # Mostrar que es x\n\n[1] 7\n\ny &lt;- 3 + 2 * x # Crear y como funcion de x \ny\n\n[1] 17\n\nclass(y)\n\n[1] \"numeric\"\n\n\nNúmeros Random con decimales\n\nru &lt;- runif(n = 100, min = 1, max = 10)\nru\n\n  [1] 6.799305 9.520070 9.725174 8.830633 6.871885 1.335451 6.195577 8.790724\n  [9] 1.585075 1.078724 5.722346 3.468438 5.518768 2.991847 1.089793 1.476719\n [17] 9.111789 2.101010 1.087487 7.877774 9.865356 4.757106 8.814464 8.492182\n [25] 7.130898 7.867023 6.521540 3.818409 3.862111 6.012153 5.584035 6.560863\n [33] 5.270028 7.108809 1.895420 1.151278 1.582472 8.576308 4.509436 9.539154\n [41] 7.299488 6.016688 5.655518 5.985131 1.695694 5.805775 4.102286 7.466406\n [49] 4.738818 6.327122 1.107299 5.709943 9.453834 2.847198 2.014526 7.817694\n [57] 4.934211 7.433961 2.178353 5.546824 1.598258 6.784450 2.263365 7.229912\n [65] 9.318177 3.390186 4.591581 2.567105 9.694240 6.589062 2.488258 3.402812\n [73] 7.436055 5.748363 7.431929 8.249274 7.256058 1.218908 2.677053 1.863686\n [81] 5.367192 1.769101 4.908961 4.344064 2.613289 1.093984 6.515284 8.926874\n [89] 5.953790 7.581751 7.603623 8.803680 9.495467 9.636963 1.708248 4.609282\n [97] 5.985045 3.924190 1.462628 9.612543\n\n\n\nhist(ru, breaks = 20, col = \"orange\", border = \"gray60\", \n     main = \"Histograma de valores Random\")\n\n\n\n\n\n\n\n\nNúmeros Random Enteros\nSimular los lanzamientos de un dado\n\nsample.int(n = 6, size = 10, replace = T)\n\n [1] 2 2 5 4 6 4 6 5 1 2\n\n\n\n\nC.1.2 Variables de Caracter\n\nch &lt;- \"Chile\" # Definir variable (objeto) ch que sea la palabra \"Chile\"\nsn &lt;- \"Santiago\"\nch # Mostrar ch\n\n[1] \"Chile\"\n\nsn\n\n[1] \"Santiago\"\n\n\nUnir variables de texto con paste()\n\nch &lt;- \"Chile\" # Definir variable (objeto) ch que sea la palabra \"Chile\"\nsn &lt;- \"Santiago\"\nunion &lt;- paste(sn,ch, sep = \", \")\nunion\n\n[1] \"Santiago, Chile\"\n\n\nUtilizar paste0()\n\nunion &lt;- paste(\"Provincia de \", sn,ch, sep = \", \")\nunion\n\n[1] \"Provincia de , Santiago, Chile\"\n\nunion0 &lt;- paste0(\"Provincia de \", sn, \", \", ch)\nunion0\n\n[1] \"Provincia de Santiago, Chile\"\n\n\nBuscar y reemplazar con gsub\n\nav &lt;- \"Av. Apoquindo\"\ncomuna &lt;- \"comuna de Las Condes\"\ncalle &lt;- paste(av, comuna, union0, sep = \", \")\ncalle\n\n[1] \"Av. Apoquindo, comuna de Las Condes, Provincia de Santiago, Chile\"\n\n# reemplazar Av. por Avenida\ncalle_new &lt;- gsub(pattern = \"Av.\", replacement = \"Avenida\", x = calle)\ncalle_new\n\n[1] \"Avenida Apoquindo, comuna de Las Condes, Provincia de Santiago, Chile\""
  },
  {
    "objectID": "variables.html#estructuras-de-datos",
    "href": "variables.html#estructuras-de-datos",
    "title": "Appendix C — Variables en R",
    "section": "C.2 Estructuras de Datos",
    "text": "C.2 Estructuras de Datos\nLas variables pueden ser un conjunto de números y caracteres ordenados de varias maneras. El orden que se les da depende de lo que queremos lograr con estos.\n\nVector\nMatrices\nDataframes\nFactores\nListas\n\n\nC.2.1 Vectores\nVector Cadenas unidimensionales (es decir una sola columna o fila) de un tipo único de valores (numéricos, caracteres, etc.)\n\nvec &lt;-  c(4, 3, 1, 5, 8, 16)\nvec\n\n[1]  4  3  1  5  8 16\n\nclass(vec)\n\n[1] \"numeric\"\n\nstr(vec)\n\n num [1:6] 4 3 1 5 8 16\n\n\nPodemos seleccionar parte del vector:\n\n# EL primer índice en R es 1 (en otros lenguajes de programación es 0)\nvec[3]\n\n[1] 1\n\n\nLa selección también puede ser hecha con una condición, de tal manera que solo seleccione aquella parte del vector que cumple con la condición.\nMayor a:\n\nvec[vec &gt;= 4]\n\n[1]  4  5  8 16\n\n\nContenido en:\n\nvec[vec %in% c(3, 8, 7, 29)]\n\n[1] 3 8\n\n\nNegación de la condición:\n\nvec[!vec &lt;= 3]\n\n[1]  4  5  8 16\n\n\nTambién podemos realizar operaciones matemáticas simples aplicadas al vector, por ejemplo una suma:\n\nvec2  &lt;-  c(7, 10, 1)\nvec + vec2\n\n[1] 11 13  2 12 18 17\n\n\n\n\nC.2.2 Listas\nSon estructuras eficientes y flexibles, que permiten combinar distintas clases de elementos :\n\nlista &lt;-  list(1, 2, 3, \"cosa\", x, y)\nlista\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n\n[[4]]\n[1] \"cosa\"\n\n[[5]]\n[1] 7\n\n[[6]]\n[1] 17\n\nstr(lista)\n\nList of 6\n $ : num 1\n $ : num 2\n $ : num 3\n $ : chr \"cosa\"\n $ : num 7\n $ : num 17\n\n\n\n#Tambien se puede seleccionar parte de una lista, usando el doble corchete:\nlista[[3]]\n\n[1] 3\n\n\nComo inspeccionar una lista con Rstudio\n\n\n\n\n\nC.2.3 Matrices\nSon estructuras de datos con 2 dimensiones, horizontal y la vertical (filas y columnas). Podemos construirlas usando la función “matrix”, con un vector inicial y sus dimensiones:\n\nn &lt;- matrix(c(1.3, 2.8, 3.5, 6.4, 5.3, 6.2, 7, 4.5, 2.4, 6.3, 5.6, 5.3, 6.6, 7, 4.3),\n  nrow = 5, ncol = 3, byrow = TRUE)\nn\n\n     [,1] [,2] [,3]\n[1,]  1.3  2.8  3.5\n[2,]  6.4  5.3  6.2\n[3,]  7.0  4.5  2.4\n[4,]  6.3  5.6  5.3\n[5,]  6.6  7.0  4.3\n\n\nLa matriz tiene 2 dimensiones, por lo que para seleccionar partes de ella es necesario declarar dos dimensiones separadas por una coma. A la izquierda van las filas y a la derecha las columnas. Un valor vacío indica que se seleccionan todos los valores posibles.\n\nn[1,2]\n\n[1] 2.8\n\n\n\nn[,3]\n\n[1] 3.5 6.2 2.4 5.3 4.3\n\n\n\n\nC.2.4 Dataframes\nEstructura mas clásica de datos, es una matriz pero con mas atributos como nombres de columna y/o fila. Es lo mas similar en R a una tabla excel o la tabla de atributos. La manera mas simple de crear un dataframe es a partir de una matriz usando la función as.data.frame() :\n\ndf&lt;- as.data.frame(n)\ndf\n\n   V1  V2  V3\n1 1.3 2.8 3.5\n2 6.4 5.3 6.2\n3 7.0 4.5 2.4\n4 6.3 5.6 5.3\n5 6.6 7.0 4.3\n\n\nPodemos asignar nombres a las columnas del dataframe\n\nnames(df)&lt;- c(\"control_1\",\"control_2\",\"examen\")\ndf\n\n  control_1 control_2 examen\n1       1.3       2.8    3.5\n2       6.4       5.3    6.2\n3       7.0       4.5    2.4\n4       6.3       5.6    5.3\n5       6.6       7.0    4.3\n\n\nY a las filas del dataframe\n\ndf$alumno &lt;- c(\"Sofia\",\"Tomas\",\"Luciano\",\"Julian\",\"Gabriela\")\ndf\n\n  control_1 control_2 examen   alumno\n1       1.3       2.8    3.5    Sofia\n2       6.4       5.3    6.2    Tomas\n3       7.0       4.5    2.4  Luciano\n4       6.3       5.6    5.3   Julian\n5       6.6       7.0    4.3 Gabriela\n\n\nTambién podemos realizar operaciones entre vectores del dataframe:\n\ndf$promedio_final &lt;-  0.3*df$control_1 + 0.3*df$control_2 + 0.4*df$examen\ndf\n\n  control_1 control_2 examen   alumno promedio_final\n1       1.3       2.8    3.5    Sofia           2.63\n2       6.4       5.3    6.2    Tomas           5.99\n3       7.0       4.5    2.4  Luciano           4.41\n4       6.3       5.6    5.3   Julian           5.69\n5       6.6       7.0    4.3 Gabriela           5.80"
  },
  {
    "objectID": "control_r.html#estructuras-condicionales",
    "href": "control_r.html#estructuras-condicionales",
    "title": "Appendix D — Estructuras en R",
    "section": "D.1 Estructuras condicionales",
    "text": "D.1 Estructuras condicionales\nLas estructuras condicionales son una de las tres estructuras de control principales en R. Estas estructuras permiten ejecutar un bloque de código solo si se cumple una condición determinada.\nLa estructura condicional más común en R es “if”. La sintaxis básica de la estructura “if” es la siguiente:\n\nif(Condición) {\n  operaciones_si_la_condición_es_TRUE\n}\n\nLa “condición” es una expresión lógica que evalúa a verdadero o falso. Si la condición es verdadera, el bloque de código dentro del “if” se ejecutará. Si la condición es falsa, el bloque de código dentro del “if” se ignorará.\nPor ejemplo, le pedimos a R que nos muestre el texto “Verdadero” si la condición se cumple.\n\n# Se cumple la condición y se muestra \"verdadero\"\nif(4 &gt; 3) {\n  \"Verdadero\"\n}\n\n[1] \"Verdadero\"\n\n\n\n# No se cumple la condición y no pasa nada\nif(4 &gt; 5) {\n  \"Verdadero\"\n}\n\nTambién se puede agregar un bloque de código opcional para el caso en que la condición sea falsa utilizando la estructura “else”. La sintaxis básica de la estructura “if” con “else” es la siguie\nSI esta condición es es cierta, ENTONCES haz estas operaciones, DE OTRO MODO haz estas otras operaciones.\n\nif(condición) {\n  operaciones_si_la_condición_es_TRUE\n} else {\n  operaciones_si_la_condición_es_FALSE\n}\n\nUsando los ejemplos anteriores, podemos mostrar “Falso” si no se cumple la condición, en lugar de que no ocurra nada\n\n# Se cumple la condición y se muestra \"Verdadero\"\nif(4 &gt; 3) {\n  \"Verdadero\"\n} else {\n  \"Falso\"\n}\n\n[1] \"Verdadero\"\n\n\nLa estructura “ifelse” es otra forma de estructura condicional que permite ejecutar diferentes bloques de código en función de la condición. La sintaxis básica de la estructura “ifelse” es la siguiente:\n\nifelse(condición, expresión1, expresión2)\n\nSi la “condición” es verdadera, se ejecutará “expresión1”. Si la “condición” es falsa, se ejecutará “expresión2”.\nAdemás, se pueden anidar varias estructuras condicionales utilizando la sintaxis de “if” y “else”. Por ejemplo:\n\nif (condición1) {\n  # Código a ejecutar si la condición1 es verdadera\n} else if (condición2) {\n  # Código a ejecutar si la condición1 es falsa y la condición2 es verdadera\n} else {\n  # Código a ejecutar si todas las condiciones son falsas\n}\n\nEn resumen, las estructuras condicionales en R son herramientas muy útiles para controlar el flujo de ejecución de un programa en función de ciertas condiciones. Estas estructuras permiten crear soluciones más eficientes y complejas al permitir que los programas tomen decisiones y realicen acciones en función de las condiciones que se presenten."
  },
  {
    "objectID": "control_r.html#sec-bucles",
    "href": "control_r.html#sec-bucles",
    "title": "Appendix D — Estructuras en R",
    "section": "D.2 Estructuras de bucles",
    "text": "D.2 Estructuras de bucles\nLas estructuras de bucles son una de las tres estructuras de control principales en R. Estas estructuras permiten ejecutar un bloque de código repetidamente mientras se cumpla una condición determinada. En R, existen tres estructuras de bucles principales: “while”, “for” y “repeat”.\nBeneficios\n\nEs más fácil ver el objetivo de tu código; lo diferente llama más atención a la vista que aquello que permanece igual.\nEs más sencillo responder a cambios en los requerimientos. A medida que tus necesidades cambian, solo necesitarás realizar cambios en un lugar, en vez de recordar cambiar en cada lugar donde copiaste y pegaste el código.\nEs probable que tengas menos errores porque cada línea de código es utilizada en más lugares.\n\n\nD.2.1 Estructura de bucle “for”:\nLa estructura “for” permite repetir la ejecución de un bloque de código un número determinado de veces. La sintaxis básica de la estructura “for” es la siguiente:\n\nfor (variable in secuencia) {\n  # Código a ejecutar para cada elemento en la secuencia\n}\n\nLa “secuencia” es un objeto que contiene una serie de elementos. La “variable” toma el valor de cada elemento de la secuencia en cada iteración del bucle. En cada iteración, se ejecutará el bloque de código dentro del “for” para ese valor de la variable.\nEjemplo simple: print una secuencia\n\nfor (i in 1:5){\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nEjemplo 2: Guardando los resultados en un vector\n\ndado &lt;- 1:6\nmi_vector &lt;- NULL\nfor(cara in dado) {\n  mi_vector[cara] &lt;- cara ^ 2\n}\nmi_vector\n\n[1]  1  4  9 16 25 36\n\n\nEjemplo 3: Loops con vectores\n\nalumnos &lt;- c(\"Carmen\", \"Adriana\", \"Marco\", \"Fabi\", \"Brenda\")\n\nfor(i in 1:length(alumnos)) {\n  print(paste(\"Hola,\", alumnos[i], sep = \" \"))\n}\n\n[1] \"Hola, Carmen\"\n[1] \"Hola, Adriana\"\n[1] \"Hola, Marco\"\n[1] \"Hola, Fabi\"\n[1] \"Hola, Brenda\"\n\n\nEjemplo 4: loops en Dataframes\n\ndf &lt;- data.frame(a = rnorm(10), b = rnorm(10),\n                 c = rnorm(10), d = rnorm(10))\n\nfor(i in 1:ncol(df)){\n  promedio = mean(df[,i])\n  print(promedio)\n}\n\n[1] 0.4265535\n[1] 0.4043566\n[1] 0.1688598\n[1] 0.2375841\n\n\n\n\nD.2.2 Estructura de bucle “while”:\nLa estructura “while” permite repetir la ejecución de un bloque de código mientras se cumpla una condición determinada. La sintaxis básica de la estructura “while” es la siguiente:\n\nwhile (condición) {\n  # Código a ejecutar mientras se cumpla la condición\n}\n\nLa “condición” es una expresión lógica que evalúa a verdadero o falso. Si la condición es verdadera, se ejecutará el bloque de código dentro del “while”. Este proceso se repetirá hasta que la condición sea falsa.\n\n\nD.2.3 Estructura de bucle “repeat”:\n\nrepeat {\n  # Código a ejecutar de manera indefinida\n  if (condición) {\n    break\n  }\n}\n\nEl bloque de código dentro del “repeat” se ejecutará de manera indefinida hasta que se encuentre la sentencia “break”, que permite salir del bucle. La “condición” es una expresión lógica que evalúa a verdadero o falso. Si la condición es verdadera, se ejecutará la sentencia “break” y se saldrá del bucle."
  },
  {
    "objectID": "control_r.html#estructuras-de-control-de-flujo",
    "href": "control_r.html#estructuras-de-control-de-flujo",
    "title": "Appendix D — Estructuras en R",
    "section": "D.3 Estructuras de control de flujo",
    "text": "D.3 Estructuras de control de flujo\n“next” y “break” son palabras clave importantes en R que se utilizan en las estructuras de control de flujo, específicamente en las estructuras de bucle. “next” se utiliza para saltar a la siguiente iteración del bucle sin ejecutar el resto del código dentro del bucle, mientras que “break” se utiliza para detener el bucle de forma abrupta, incluso si la condición del bucle todavía se cumple.\n\nD.3.1 Estructuras de control “next”:\n“next” se utiliza en una estructura de bucle para saltar a la siguiente iteración del bucle sin ejecutar el resto del código dentro del bucle. Es decir, si se encuentra la palabra clave “next” dentro de un bucle, se omitirá el código que viene después y el bucle pasará inmediatamente a la siguiente iteración. La palabra clave “next” es útil cuando se desea saltar una iteración específica del bucle, sin afectar el resto del código.\nPor ejemplo, en el siguiente código se utiliza la palabra clave “next” para omitir la impresión del número 3 dentro del bucle “for”:\n\nfor (i in 1:5) {\n  if (i == 3) {\n    next\n  }\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 4\n[1] 5\n\n\n\n\nD.3.2 Estructuras de control “break”:\n“break”, por otro lado, se utiliza en una estructura de bucle para detener el bucle de forma abrupta, incluso si la condición del bucle todavía se cumple. Es decir, si se encuentra la palabra clave “break” dentro de un bucle, se detendrá el bucle de inmediato y se continuará con la ejecución del código que viene después del bucle. La palabra clave “break” es útil cuando se desea detener el bucle en un punto específico sin tener que esperar a que la condición del bucle se deje de cumplir.\nPor ejemplo, en el siguiente código se utiliza la palabra clave “break” para detener el bucle “while” cuando el valor de “i” es mayor que 5:\n\ni &lt;- 1\nwhile (i &lt; 10) {\n  if (i &gt; 5) {\n    break\n  }\n  print(i)\n  i &lt;- i + 1\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5"
  },
  {
    "objectID": "control_r.html#referencias",
    "href": "control_r.html#referencias",
    "title": "Appendix D — Estructuras en R",
    "section": "D.4 Referencias:",
    "text": "D.4 Referencias:\n\nLoops y funciones en R"
  },
  {
    "objectID": "tidyverse.html#introducción-a-tidyverse",
    "href": "tidyverse.html#introducción-a-tidyverse",
    "title": "Appendix E — Tidyverse en R",
    "section": "E.1 Introducción a Tidyverse",
    "text": "E.1 Introducción a Tidyverse\nTidyverse es una colección de paquetes diseñados para Ciencia de Datos.\n\n\n\n\n\n\n# instalación\ninstall.packages(\"tidyverse\")\n\nTodos los paquetes comparten una filosofía de diseño, una gramática y estructuras de datos.\nEsta filosofía promueve\n\nEn Pipes, navegarás dentro del pipe, %&gt;%, para anidar instrucciones\nSi bien copiar-y-pegar (copy-and-paste) es una herramienta poderosa, deberías evitar utilizarla más de dos veces. Repetir el código es peligroso porque puede llevar a errores e inconsistencias.\nA medida que comiences a escribir funciones más potentes, necesitarás una base sólida acerca de las estructuras de datos.\nLas funciones nos permiten evitar la repetición de código; sin embargo, muchas veces necesitas repertir las mismas acciones con diferentes inputs. Puedes hacer esto con herramientas de iteración."
  },
  {
    "objectID": "tidyverse.html#estructura-de-un-dataframe",
    "href": "tidyverse.html#estructura-de-un-dataframe",
    "title": "Appendix E — Tidyverse en R",
    "section": "E.2 Estructura de un dataframe",
    "text": "E.2 Estructura de un dataframe\n\n\n\nLectura de Base de SII\n\nsuppressPackageStartupMessages(library(dplyr))\nsuppressPackageStartupMessages(library(sf))\ntbl_sii  &lt;- readRDS(\"data/sii/mz_constru_SII.rds\") %&gt;% \n  st_drop_geometry() # descartar geometrias solo usar la tabla de datos\n\nhead(tbl_sii)\n\n# A tibble: 6 × 10\n  n_com   manzana   reg cod_com num_manz oficinas comercio vivienda total   AREA\n  &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 IQUIQUE 1201-0      1    1201        0        0        0        0     0   585.\n2 IQUIQUE 1201-0      1    1201        0        0        0        0     0 17291.\n3 ALTO H… 1211-0      1    1211        0        0        0        0     0  1859.\n4 ALTO H… 1211-0      1    1211        0        0        0        0     0   442.\n5 ALTO H… 1211-0      1    1211        0        0        0        0     0   205.\n6 ALTO H… 1211-0      1    1211        0        0        0        0     0  1200."
  },
  {
    "objectID": "tidyverse.html#funciones-básicas-dplyr",
    "href": "tidyverse.html#funciones-básicas-dplyr",
    "title": "Appendix E — Tidyverse en R",
    "section": "E.3 Funciones básicas dplyr",
    "text": "E.3 Funciones básicas dplyr\n\n\n\n\nE.3.1 Select\nselect Seleccionar variables relevantes\n\n# seleccionar nomnres de columnas que deseo conservar\ntbl_sii %&gt;%\n  select(n_com, oficinas, comercio, vivienda)\n\n# A tibble: 210,662 × 4\n   n_com         oficinas comercio vivienda\n   &lt;chr&gt;            &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n 1 IQUIQUE              0        0        0\n 2 IQUIQUE              0        0        0\n 3 ALTO HOSPICIO        0        0        0\n 4 ALTO HOSPICIO        0        0        0\n 5 ALTO HOSPICIO        0        0        0\n 6 ALTO HOSPICIO        0        0        0\n 7 ALTO HOSPICIO        0        0        0\n 8 ALTO HOSPICIO        0        0        0\n 9 ALTO HOSPICIO        0        0        0\n10 ALTO HOSPICIO        0        0        0\n# ℹ 210,652 more rows\n\n# seleccionar nomnres de columnas que deseo eliminar anteponiendo un \"-\"\ntbl_sii %&gt;%\n  select(-cod_com)\n\n# A tibble: 210,662 × 9\n   n_com         manzana   reg num_manz oficinas comercio vivienda total   AREA\n   &lt;chr&gt;         &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 IQUIQUE       1201-0      1        0        0        0        0     0   585.\n 2 IQUIQUE       1201-0      1        0        0        0        0     0 17291.\n 3 ALTO HOSPICIO 1211-0      1        0        0        0        0     0  1859.\n 4 ALTO HOSPICIO 1211-0      1        0        0        0        0     0   442.\n 5 ALTO HOSPICIO 1211-0      1        0        0        0        0     0   205.\n 6 ALTO HOSPICIO 1211-0      1        0        0        0        0     0  1200.\n 7 ALTO HOSPICIO 1211-0      1        0        0        0        0     0  4548.\n 8 ALTO HOSPICIO 1211-0      1        0        0        0        0     0   130.\n 9 ALTO HOSPICIO 1211-0      1        0        0        0        0     0   300.\n10 ALTO HOSPICIO 1211-0      1        0        0        0        0     0  6488.\n# ℹ 210,652 more rows\n\n\n\n\nE.3.2 Filter\n\nmi_comuna &lt;- \"LAS CONDES\" \n\nsii_com &lt;- tbl_sii %&gt;%\n  filter(n_com == mi_comuna) \n \nhead(sii_com, 5)\n\n# A tibble: 5 × 10\n  n_com    manzana   reg cod_com num_manz oficinas comercio vivienda total  AREA\n  &lt;chr&gt;    &lt;chr&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 LAS CON… 15108-…    13   15108     2358        0        0     1316  1390 2358.\n2 LAS CON… 15108-…    13   15108     2360        0        0     1590  1622 2280.\n3 LAS CON… 15108-…    13   15108     2362        0        0     1436  1502 2659.\n4 LAS CON… 15108-…    13   15108     2364        0        0     1926  1926 3348.\n5 LAS CON… 15108-…    13   15108     2366        0        0     2584  2656 4390.\n\n\nfilter: Operadores Lógicos\n\n\n\n\n\n\n\n\n\n\n\nOperador\nComparación\nEjemplo\nResultado\n\n\n\n\nx | y\nx Ó y es verdadero\nTRUE | FALSE\nTRUE\n\n\nx & y\nx Y y son verdaderos\nTRUE & FALSE\nFALSE\n\n\n!x\nx no es verdadero (negación)\n!TRUE\nFALSE\n\n\nisTRUE(x)\nx es verdadero (afirmación)\nisTRUE(TRUE)\nTRUE\n\n\n\n\n\nFiltrar las manzanas que tengan valores de oficina y comercio mayores a 0\n\nsii_com %&gt;%\n  filter(oficinas &gt; 0 & comercio &gt; 0) \n\n# A tibble: 493 × 10\n   n_com manzana   reg cod_com num_manz oficinas comercio vivienda  total   AREA\n   &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n 1 LAS … 15108-…    13   15108     2400     322     3388    65422  1.22e5 1.06e5\n 2 LAS … 15108-…    13   15108     2407   30864     2518        0  7.50e4 4.04e3\n 3 LAS … 15108-…    13   15108     1392     424     9902        0  1.58e4 1.27e4\n 4 LAS … 15108-…    13   15108      336   45190     1432        0  8.28e4 3.24e3\n 5 LAS … 15108-…    13   15108      338     424.     244.    9993. 1.17e4 1.11e4\n 6 LAS … 15108-…    13   15108      338     414.     238.    9765. 1.14e4 1.06e4\n 7 LAS … 15108-…    13   15108      339    1120     5274     7748  1.49e4 9.38e3\n 8 LAS … 15108-…    13   15108      340     250       72    55206  7.23e4 1.22e4\n 9 LAS … 15108-…    13   15108      342     494     1914    47690  6.97e4 1.62e4\n10 LAS … 15108-…    13   15108      349   17826     1568        0  3.38e4 1.84e3\n# ℹ 483 more rows"
  },
  {
    "objectID": "tidyverse.html#resúmenes-estadísticos-con-dplyr",
    "href": "tidyverse.html#resúmenes-estadísticos-con-dplyr",
    "title": "Appendix E — Tidyverse en R",
    "section": "E.4 Resúmenes Estadísticos con dplyr",
    "text": "E.4 Resúmenes Estadísticos con dplyr\n\n\n\nContabilizar cuantos metros cuadrados de oficina por cada comuna.\n\ntbl_resumen &lt;-  tbl_sii %&gt;%\n  group_by(n_com) %&gt;%\n  summarise(Cantidad_mz = n(),\n            Total_of = sum(oficinas)) %&gt;%\n  arrange(desc(Total_of)) # Ordenar\n\ntbl_resumen\n\n# A tibble: 170 × 3\n   n_com           Cantidad_mz Total_of\n   &lt;chr&gt;                 &lt;int&gt;    &lt;dbl&gt;\n 1 SANTIAGO CENTRO         686  6105996\n 2 LAS CONDES             2310  4248336\n 3 PROVIDENCIA             885  3495426\n 4 HUECHURABA             1160  1006138\n 5 QUILICURA              2592   751874\n 6 VITACURA                950   743734\n 7 SANTIAGO SUR            623   669270\n 8 Ã‘UÃ‘OA                1337   637982\n 9 SANTIAGO OESTE          586   586724\n10 PUDAHUEL               2775   561868\n# ℹ 160 more rows\n\n\nActividad\n\nContabilizar cuantos metros cuadrados de Comercio hay por cada comuna rdenar de mayor a menor.\nCrear tabla con las 10 comunas que tienen mayor densisdad de Comercio\n\n\n\n\n\n\n\nDensidad de comercio\n\n\n\nSe puede entender como la división de la cantidad de metros cuadrados de comercio dividio por el total de metros cuadrados."
  },
  {
    "objectID": "tidyverse.html#visualización-de-variables",
    "href": "tidyverse.html#visualización-de-variables",
    "title": "Appendix E — Tidyverse en R",
    "section": "E.5 Visualización de Variables",
    "text": "E.5 Visualización de Variables\n\nE.5.1 Función Plot\n\noptions(scipen = 999) # evitas notación cientiífica\nhist(sii_com$vivienda, breaks = 50,\n     main = \"Histograma mt2 de Viviendas\", col = \"#225ea8\")\n\n\n\n# colores:https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3\n\n\n\nE.5.2 Package ggplot2\n\nlibrary(ggplot2)\nggplot(sii_com, aes(x = vivienda)) + \n  geom_histogram(bins = 50, fill = \"#225ea8\", color =\"black\")\n\n\n\n\n\n\n\n\nggplot2 con estilos y características\n\nggplot(sii_com, aes(x = vivienda)) +\n  geom_histogram(bins = 50, color = \"#c7e9b4\", fill = \"#1d91c0\")+\n  theme_bw()+\n  labs(title=\"Histograma mt2 de Viviendas\", x =\"Mt2. Viviendas\", y = \"Frecuencias\")+\n  theme(plot.title = element_text(face = \"bold\",colour= \"gray60\", size=10))"
  },
  {
    "objectID": "tidyverse.html#referencias",
    "href": "tidyverse.html#referencias",
    "title": "Appendix E — Tidyverse en R",
    "section": "E.6 Referencias:",
    "text": "E.6 Referencias:\n\nTidyverse\nPaletas de colores"
  },
  {
    "objectID": "workflow.html#introducción",
    "href": "workflow.html#introducción",
    "title": "5  Workflow general",
    "section": "5.1 Introducción",
    "text": "5.1 Introducción\n\n\n\nFigure 5.1: Flujo de trabajo general para que se realizará en esté capítulo\n\n\nEn este capítulo se realizará un flujo de trabajo general para la consolidación de tres productos generales que serán utilizados para análisis futuros como también para el trabajo final. El flujo de trabajo general se encuentra en la Figure 5.1, donde se obtendrá los siguientes productos:\n\nExcel por Comuna y Mes\nEvolución por Comunas espacial\nEvolución por Zonas espacial\n\nA continución se procede a aplicar de forma detallada los procedimientos para obtener cada uno de estos productos."
  },
  {
    "objectID": "workflow.html#section",
    "href": "workflow.html#section",
    "title": "5  Workflow general",
    "section": "5.2 ",
    "text": "5.2"
  },
  {
    "objectID": "workflow.html#excel-de-casos-por-comuna-y-mes",
    "href": "workflow.html#excel-de-casos-por-comuna-y-mes",
    "title": "5  Workflow general",
    "section": "5.2 Excel de Casos por Comuna y mes",
    "text": "5.2 Excel de Casos por Comuna y mes\n ## Evolución por Comunas espacial"
  },
  {
    "objectID": "workflow.html#evolución-por-zonas-espacial",
    "href": "workflow.html#evolución-por-zonas-espacial",
    "title": "5  Workflow general",
    "section": "5.4 Evolución por Zonas espacial",
    "text": "5.4 Evolución por Zonas espacial"
  },
  {
    "objectID": "workflow.html#excel-por-comuna-y-mes",
    "href": "workflow.html#excel-por-comuna-y-mes",
    "title": "5  Workflow general",
    "section": "5.2 Excel por Comuna y Mes",
    "text": "5.2 Excel por Comuna y Mes\n\n\n\nFigure 5.2: Flujo de Trabajo para generar Excel de frecuencia de delitos por Comuna y Mes\n\n\nEste producto se pretende consolidar los datos de Casos Policiales Totales y la base de Denuncia Seguro en un archivo que represente la frecuecia de delitos, previamente limpiados y homolgados, a escala comunal y por meses por meses. El resultado será en formato excel para facilitar el proceso de análsis posterior. El flujo de trabajo en específico para generar este producto se representa en Figure 5.2.\nLibrerías de uso general\n\n# librerías ---------------------------------------------------------------\nlibrary(openxlsx)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(sf)\n\n\n5.2.1 Procedimiento a base de Denuncia Seguro\nLectura\n\n# Lectura denuncia seguro\ndenuncias &lt;- readRDS(\"data/datos_trabajo_final/denuncia_seguro.rds\") %&gt;% \n  st_as_sf() %&gt;% st_drop_geometry() %&gt;%# Descartar información espacial\n  as_tibble() # trasformación para visualizar mejor\n\nLimpieza\nEn esta etapa se crea un variable temporal de unifica el año y mes que se denominará MESES a través de una suma directa, lo que aumentará la eficiencia al momento de realizar consultas.\n\ndenuncias &lt;- denuncias %&gt;% rename(NOM_REGION = REGION) %&gt;% \n  mutate(MESES = (ANIO*100) + MES)   # agrega de año y mes (muy eficiente)\n\n# visaluzación de transformación de la fechas\ndenuncias %&gt;% select(INCIDENTE, ANIO, MES, MESES) %&gt;% head(5)\n\n# A tibble: 5 × 4\n  INCIDENTE  ANIO   MES  MESES\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1    332666  2017    12 201712\n2    332690  2017    12 201712\n3    290692  2017     4 201704\n4    290700  2017     4 201704\n5    290704  2017     4 201704\n\n\nCodificación de Tipos de Delitos\n\n# Lectura de clasificación de denuncia seguro\nclasificaden &lt;- read.xlsx(\n  \"data/datos_trabajo_final/clasificacion_denuncias.xlsx\", \n  sheet = \"tipos\") %&gt;% \n  select(-tip) # eliminación de columna\n\nclasificaden %&gt;% as_tibble() %&gt;% head(5)\n\n# A tibble: 5 × 2\n  SUBDELITO                                                      TIPO           \n  &lt;chr&gt;                                                          &lt;chr&gt;          \n1 ABANDONO DE NIÑOS.ART. 346 al 351..                            Abandono famil…\n2 ABIGEATO. ART. 448 BIS                                         Hurtos y Robos \n3 ABORTO COMETIDO POR FACULTATIVO.                               Violencia fami…\n4 ABORTO CONSENTIDO. ART. 342 Nº 3 y 344..                       Violencia fami…\n5 ABORTO SIN CONSENTIMIENTO. ARTS. 342 Nº 2 y 342 Nº 1. Art. 343 Violencia fami…\n\n\nAgregar tipología a base de Denuncia seguro, donde la variable key para hacer la unión es SUBDELITO.\n\ndenuncias &lt;- denuncias %&gt;% left_join(clasificaden, by = \"SUBDELITO\") \ndenuncias %&gt;% arrange(MESES) %&gt;% select(INCIDENTE,MESES, TIPO) %&gt;% head(5)\n\n# A tibble: 5 × 3\n  INCIDENTE  MESES TIPO          \n      &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;         \n1    130070 201401 Drogas        \n2    129250 201401 Armas         \n3    129439 201401 Drogas        \n4    130672 201401 Drogas        \n5    129311 201401 Hurtos y Robos\n\n\nArmonización de Tablas\nEn esta etapa se realizará unificación de los nombres de comunas y regiones para todas las bases que se van a trabajar, y como la base Denuncia Seguro difieren de la base de Casos Policiales, se deben homologar haciendo uso de las siguientes tablas:\n\nTablas de nombres de comunas:\n\n\nindcom &lt;- read.xlsx(\"data/datos_trabajo_final/comunas_carabineros_spd.xlsx\")\nindcom %&gt;% as_tibble() %&gt;% head(5)\n\n# A tibble: 5 × 2\n  NOM_COMUNA    COMUNA         \n  &lt;chr&gt;         &lt;chr&gt;          \n1 ALGARROBO     Algarrobo      \n2 ALHUÉ         Alhué          \n3 &lt;NA&gt;          Alto Biobío    \n4 &lt;NA&gt;          Alto del Carmen\n5 ALTO HOSPICIO Alto Hospicio  \n\n\n\nTablas de nombres regiones:\n\n\nindreg &lt;- read.xlsx(\"data/datos_trabajo_final/regiones_carabineros_spd.xlsx\")\nindreg %&gt;% as_tibble() %&gt;% head(5)\n\n# A tibble: 5 × 2\n  REGION NOM_REGION           \n   &lt;dbl&gt; &lt;chr&gt;                \n1      1 Región de Tarapacá   \n2      2 Región de Antofagasta\n3      3 Región de Atacama    \n4      4 Región de Coquimbo   \n5      5 Región de Valparaíso \n\n\nUnificación de Denuncia Seguron con tablas de nombres\n\ndenuncias &lt;- denuncias %&gt;% left_join(indcom, by = \"COMUNA\", \n                                     relationship = \"many-to-many\")\ndenuncias &lt;- denuncias %&gt;% left_join(indreg, by = \"NOM_REGION\")\n\ndenuncias %&gt;% select(COMUNA, NOM_COMUNA, NOM_REGION, REGION) %&gt;% head(5)\n\n# A tibble: 5 × 4\n  COMUNA       NOM_COMUNA   NOM_REGION                       REGION\n  &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;                             &lt;dbl&gt;\n1 La Granja    LA GRANJA    Región Metropolitana de Santiago     13\n2 Concón       CONCÓN       Región de Valparaíso                  5\n3 Coquimbo     COQUIMBO     Región de Coquimbo                    4\n4 San Bernardo SAN BERNARDO Región Metropolitana de Santiago     13\n5 La Serena    LA SERENA    Región de Coquimbo                    4\n\n\nSelección de variables\n\ndenuncias &lt;- denuncias %&gt;% \n  mutate(CLASIFICAC = \"MENSAJE\") %&gt;% \n  select(REGION,NOM_REGION,COMUNA,NOM_COMUNA,MESES,TIPO,CLASIFICAC)\n\n\n\n5.2.2 Procedimiento a base de Casos Policiales\nLectura\nPara efectos de este libro digital se tomará una muestra de los casos policiales de 10000 a nivel nacional.\n\ncasos &lt;- readRDS(\"data/datos_trabajo_final/delitos_all_categ.rds\")\ncasos %&gt;% st_drop_geometry() %&gt;% count(TIPO)\n\n\n\n\nLimpieza\n\n# Limpieza Casos Policiales\ncasos &lt;- casos %&gt;% \n  st_drop_geometry() %&gt;% \n  select(-NOM_REGION, -COMUNA) %&gt;%  # eliminar columnas\n  mutate(REGION = as.numeric(REGION),\n         MESES = year(FECHA_DEL)*100 + month(FECHA_DEL), \n         COMUNA = floor(as.numeric(ZONA)/1000000))\n\nSe debe revisar si los todos los casos policiales tienen su tipología asignada (sin valores NA) y que los nombres estén escritos de forma correcta. Lo primero se realizará revisión de las tablas de frecuencia y revisar si existen problemas.\n\n\n\n\n\n\nMuestra de 10000 casos policiales\n\n\n\nLa revisión de tablas de frecuencia va diferir con los datos totales ya que se tomó una muestra para efectos de este libro digital.\n\n\n\n# Asignación manual delitos con problemas tipo\ncasos %&gt;% count(TIPO) # llama la atención Tipo de baja fecuencia\n\n                 TIPO    n\n1    Abandono familia  172\n2        Abuso Sexual   69\n3  Abuso y Corrupción   54\n4         Aprehensión  653\n5               Armas   75\n6     Comercio Ilegal  218\n7     Comercio ilegal    1\n8               Daños  633\n9  Delitos económicos  436\n10           Desacato   71\n11         Desórdenes 2980\n12             Drogas  148\n13   Hallazgo muertes   51\n14  Hallazgo vehículo  141\n15         Homicidios    4\n16     Hurtos y Robos 1337\n17    Lesiones graves  252\n18 Presunta desgracia  221\n19     Robo domicilio  311\n20     Robo vehículos  597\n21      Robo violento  528\n22         Secuestros    3\n23     Trata personas   53\n24           Tránsito  163\n25 Violencia familiar  829\n\n\nEn este caso podemos observar que existen dos Tipos que hacen referencia a lo mismo Comercio Ilegal y Comercio ilegal.\nEn la base de casos original tambien existen delitos que no tienen tipología asignada correspondiente a NA, enconces se verificaremos si existen valores faltantes mediente la siguiente consulta:\n\n# ver NA\ncasos %&gt;% \n  filter(is.na(TIPO)) %&gt;%  #casos con Tipo NA\n  pull(DELITO) # mostrar los delitos\n\ncharacter(0)\n\n# en este caso retorna 0,\n# pero con los datos totales si va encontrar casos sin tipología.\n\nPara solucionar lo anterior se utilizará un método eficiente de buscar y reemplazar usando la función case_when() como se muestra a continuación:\n\ncasos &lt;- casos %&gt;% \n  mutate(TIPO = case_when(\n    DELITO == \"BOTILLERIA,SUPERMERC.,MINIMARKET QUE EXP.LICOR CONSUMIDO INT.LOCAL S/P\" ~ \"Desórdenes\",\n    DELITO == \"ROBO DE VEHICULO MOTORIZADO POR SORPRESA, VIOLENCIA O I_\" ~ \"Robo vehículos\",\n    DELITO == \"ROBO CON VIOLENCIA ART.436 INC 1 433,438,439\" ~ \"Robo violento\",\n    DELITO == \"VIOLENCIA INTRAFAMILIAR OTROS (LESIONES PSICOLOGICAS O LEVES)\" ~ \"Violencia familiar\",\n    TIPO == \"Comercio Ilegal\" ~ \"Comercio ilegal\",\n    .default = TIPO\n    ))\n\nRevisión de cambios ejecutados correctamente\n\ncasos %&gt;% count(TIPO) \n\n                 TIPO    n\n1    Abandono familia  172\n2        Abuso Sexual   69\n3  Abuso y Corrupción   54\n4         Aprehensión  653\n5               Armas   75\n6     Comercio ilegal  219\n7               Daños  633\n8  Delitos económicos  436\n9            Desacato   71\n10         Desórdenes 2980\n11             Drogas  148\n12   Hallazgo muertes   51\n13  Hallazgo vehículo  141\n14         Homicidios    4\n15     Hurtos y Robos 1337\n16    Lesiones graves  252\n17 Presunta desgracia  221\n18     Robo domicilio  311\n19     Robo vehículos  597\n20      Robo violento  528\n21         Secuestros    3\n22     Trata personas   53\n23           Tránsito  163\n24 Violencia familiar  829\n\n\nCodificación de Tipos de Delitos\nEste paso ya fue realizado anteriormente y ya está realizado en base de Casos Policiales, en caso que se deba realizar nuevamente esta operación se recomienda revisar Section 2.7\nArmonización de Tablas\n\ncasos &lt;- casos %&gt;% left_join(indreg, by = \"REGION\")\ncasos &lt;- casos %&gt;% \n  filter(!is.na(NOM_COMUNA)) \n\nGuardar resultados intermendios, ya que nos ayudaràn para el cálculos a nivel de ZONAS censales.\n\nsaveRDS(casos, \"data/datos_trabajo_final/resultados/casos_clean.rds\")\n\n\n\n\nSelección de variables\n\ncasos &lt;- casos %&gt;% \n  select(REGION,NOM_REGION,COMUNA,NOM_COMUNA,MESES,TIPO,CLASIFICAC)\n\n\n\n5.2.3 Fusión de tablas y estructuración en panel long\nUnión de las tablas\n\nhechos &lt;- rbind(casos,denuncias)\n\nContabilizar los Delitos\n\nhechoscomunames &lt;- hechos %&gt;%\n  group_by(REGION,NOM_REGION,COMUNA,NOM_COMUNA,MESES,CLASIFICAC,TIPO) %&gt;%\n  summarise(HECHOS = n(), .groups = \"keep\")\n\n# hechoscomunames\n\nfiltrar por fecha desde enero del 2017, encones podríamos filtar con la fechas superror al número 201700\n\nhechoscomunames &lt;- hechoscomunames %&gt;% \n  filter(MESES &gt; 201700)\n\n# hechoscomunames\n\n\n\n5.2.4 Guardar los resultados en Excel\n\n# Guardar Excel\nwrite.xlsx(hechoscomunames, \n           \"data/datos_trabajo_final/resultados/hechoscomunames.xlsx\", \n           rownames = F)\nsaveRDS(hechoscomunames, \n        \"data/datos_trabajo_final/resultados/hechoscomunames.rds\")"
  },
  {
    "objectID": "workflow.html#evolución-por-comunas-espacial",
    "href": "workflow.html#evolución-por-comunas-espacial",
    "title": "5  Workflow general",
    "section": "5.3 Evolución por Comunas espacial",
    "text": "5.3 Evolución por Comunas espacial\n\n\n\nFigure 5.3: Diagrama de flujo para el cáculo de evolución de delitos por Comunas\n\n\nCon el objetivo de medir la evolución de casos policiales en dos periodos de tiempo, se contruirá un indicador de variabilidad a nivel comunal con representación espacial como punto y polígono.\nDe acuedo al diagrama de flujo de esta subsección Figure 5.3 se utilizará los resultados limpieza y codificación de tipos de delitos de casos policiales realizados anteriormente.\nPrimeramente se descartará la información de Denuncia Seguro, dejado solo la clasificación de “DENUNCIA” y “DETENCIÓN”\n\ndelcomuna &lt;- hechoscomunames %&gt;% \n  filter(CLASIFICAC %in% c(\"DENUNCIA\",\"DETENCION\"))\n\nSelección de Periodos, cálculo de frecuencias y variación\nTabla de medidas estadísticas de frecuencia de delitos\n\nvarianzas_base &lt;- delcomuna %&gt;% \n  group_by(COMUNA, TIPO) %&gt;% \n  summarise(varianza = sd(HECHOS),\n            cantidad = sum(HECHOS),  .groups = \"keep\")\n\nhead(varianzas_base)\n\n# A tibble: 6 × 4\n# Groups:   COMUNA, TIPO [6]\n  COMUNA TIPO               varianza cantidad\n  &lt;chr&gt;  &lt;chr&gt;                 &lt;dbl&gt;    &lt;int&gt;\n1 10101  Abandono familia      0            4\n2 10101  Abuso y Corrupción    0            2\n3 10101  Aprehensión           0.354        9\n4 10101  Armas                 0            3\n5 10101  Comercio ilegal       0            2\n6 10101  Daños                 0.316       11\n\n\n\nPeriodo 1\n\n\nini &lt;- delcomuna %&gt;%\n  filter(MESES %in% 201707:201712) %&gt;% \n  group_by(COMUNA, TIPO) %&gt;% \n  summarise(inicio = sum(HECHOS),  .groups = \"keep\")\n\n\nPeriodo 2\n\n\nfin &lt;- delcomuna %&gt;%\n  filter(MESES %in% 202207:202212) %&gt;% \n  group_by(COMUNA, TIPO) %&gt;% \n  summarise(fin = sum(HECHOS),  .groups = \"keep\")\n\n\nConsolidación\n\n\nadjvar &lt;- varianzas_base %&gt;% \n  left_join(ini, by = c(\"COMUNA\", \"TIPO\")) %&gt;% \n  left_join(fin, by = c(\"COMUNA\", \"TIPO\")) %&gt;% \n  mutate_if(.predicate = is.numeric,\n            .funs = function(x) ifelse(is.na(x), 0, x)) # si es NA -&gt; 0\n\n\nIndicador de Variación\n\n\nadjvar &lt;- adjvar %&gt;% \n  mutate(adjvar = (fin-inicio)/(fin+inicio)) %&gt;% \n  mutate_if(.predicate = is.numeric,\n            .funs = function(x) ifelse(is.na(x), 0, x))\nadjvar\n\n# A tibble: 2,076 × 7\n# Groups:   COMUNA, TIPO [2,076]\n   COMUNA TIPO               varianza cantidad inicio   fin adjvar\n   &lt;chr&gt;  &lt;chr&gt;                 &lt;dbl&gt;    &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 10101  Abandono familia      0            4      0     1      1\n 2 10101  Abuso y Corrupción    0            2      1     0     -1\n 3 10101  Aprehensión           0.354        9      4     0     -1\n 4 10101  Armas                 0            3      0     0      0\n 5 10101  Comercio ilegal       0            2      0     0      0\n 6 10101  Daños                 0.316       11      1     0     -1\n 7 10101  Delitos económicos    0            9      0     1      1\n 8 10101  Desacato              0            3      1     0     -1\n 9 10101  Desórdenes            0.648       67      6     6      0\n10 10101  Drogas                0            1      0     0      0\n# ℹ 2,066 more rows\n\n\n\nHistograma de las diferencias normalizadas entre periodos\n\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\nlibrary(hrbrthemes)\np &lt;- adjvar %&gt;%\n  ggplot( aes(x=adjvar)) +\n  geom_histogram( binwidth=0.1, \n                  fill=\"#69b3a2\", color=\"#e9ecef\", alpha=0.9) +\n  scale_x_continuous(breaks = seq(-1, 1, by = 0.2))+\n  ggtitle(\"Histograma de Variación Normalizada (muestra)\") +\n  theme_ipsum() +\n  theme(\n    plot.title = element_text(size=15)\n  )\np\n\n\n\n\n\nRelación del valor normalizado con la diferencia real\n\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\nvar_max &lt;- max(adjvar$fin-adjvar$inicio, na.rm = T)\na &lt;- 1\nb &lt;- 1:20\n\ndata &lt;- expand_grid(a, b) %&gt;% \n  mutate(cambio = (b-a)/(a+b))\n\nv &lt;- ggplot(data = data, aes(x = b, y = cambio))+\n  geom_line(color = \"#69b3a2\", linewidth =1)+\n  scale_y_continuous(breaks = seq(0, 1.2, by = 0.1))+\n  scale_x_continuous(breaks = seq(0, 20, by = 1))+\n  ggtitle(\"Representación de la Variación Normalizada\")+\n  theme_ipsum()+\n  theme_bw()\n\nv\n\n\n\n\nEstructuración en Panel Wide\nEn este paso cada Tipo de delitos será columna entonces los nombres se deben abreviar, pero de una forma segura, evitando la signación manual. Por lo anterior, este procedimiento se realizarà mediante un diccionario de abreviaciones, de la siguiente forma:\n\n# renombrar TIPO con diccionario\nabrev_tipos &lt;- read.xlsx(\"data/datos_trabajo_final/abreviaciones.xlsx\")\nabrev_tipos\n\n   Abreviacion        Tipo.delito\n1       AbCorr Abuso y Corrupción\n2        AbFam   Abandono familia\n3        AbSex       Abuso Sexual\n4        Apreh        Aprehensión\n5        Armas              Armas\n6        ComIl    Comercio ilegal\n7        Danos              Daños\n8        DelEc Delitos económicos\n9        Desac           Desacato\n10       Desor         Desórdenes\n11       Droga             Drogas\n12      HallMu   Hallazgo muertes\n13      HallVe  Hallazgo vehículo\n14       Homic         Homicidios\n15       HuRob     Hurtos y Robos\n16      LesGra    Lesiones graves\n17      PreDes Presunta desgracia\n18       RoDom     Robo domicilio\n19        RoVe     Robo vehículos\n20       RoVio      Robo violento\n21      Secues         Secuestros\n22       Trans           Tránsito\n23      TraPer     Trata personas\n24      VioFam Violencia familiar\n\n\nInsertar las abreviaciones a la base y reemplazar por TIPO\n\nadjvar &lt;- adjvar %&gt;% \n  left_join(abrev_tipos, by = c(\"TIPO\" = \"Tipo.delito\")) %&gt;% \n  mutate(TIPO = Abreviacion) %&gt;% \n  select(-Abreviacion)\nadjvar\n\n# A tibble: 2,076 × 7\n# Groups:   COMUNA, TIPO [2,076]\n   COMUNA TIPO   varianza cantidad inicio   fin adjvar\n   &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;    &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 10101  AbFam     0            4      0     1      1\n 2 10101  AbCorr    0            2      1     0     -1\n 3 10101  Apreh     0.354        9      4     0     -1\n 4 10101  Armas     0            3      0     0      0\n 5 10101  ComIl     0            2      0     0      0\n 6 10101  Danos     0.316       11      1     0     -1\n 7 10101  DelEc     0            9      0     1      1\n 8 10101  Desac     0            3      1     0     -1\n 9 10101  Desor     0.648       67      6     6      0\n10 10101  Droga     0            1      0     0      0\n# ℹ 2,066 more rows\n\n\nTransformar en formato wider\n\n# Pivot Wider\nvarianzas_w &lt;- adjvar%&gt;% \n  select(-varianza, -cantidad, -inicio, -fin ) %&gt;% \n  pivot_wider(names_from = TIPO,\n              values_from = c(adjvar), values_fill = 0) %&gt;% \n  mutate(COMUNA = sprintf(\"%05d\", as.numeric(COMUNA)))\nvarianzas_w\n\n# A tibble: 288 × 25\n# Groups:   COMUNA [288]\n   COMUNA AbFam AbCorr Apreh Armas ComIl Danos DelEc Desac Desor Droga HallMu\n   &lt;chr&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 10101      1     -1    -1     0     0    -1     1    -1     0     0      0\n 2 10102      0      0     0     0     0     0     0     0     0     0      0\n 3 10104      0      0     0     0     0     0     0     0     0     0      0\n 4 10105      0      0     0     0     0     0     0     0     1     0      0\n 5 10106      0      0     0     0     0     0     0     0     0     0      0\n 6 10107      0      0     0     0     0     0     0     0     1     0      0\n 7 10108      0      0     0     0     0     0     0     0     0     0      0\n 8 10109      0      0    -1     0     0     0    -1     0    -1     0      0\n 9 10201      0      0     0     0     0     0     0     0    -1     0      0\n10 10202      0      0     0     0     0     0     0     0     0     0      0\n# ℹ 278 more rows\n# ℹ 13 more variables: HuRob &lt;dbl&gt;, LesGra &lt;dbl&gt;, PreDes &lt;dbl&gt;, RoDom &lt;dbl&gt;,\n#   RoVe &lt;dbl&gt;, RoVio &lt;dbl&gt;, TraPer &lt;dbl&gt;, VioFam &lt;dbl&gt;, AbSex &lt;dbl&gt;,\n#   Trans &lt;dbl&gt;, HallVe &lt;dbl&gt;, Secues &lt;dbl&gt;, Homic &lt;dbl&gt;\n\n\nGuardar Resultados Espacial\n\nLectura de Archivo de poligonos comunales del INE\n\n\ncomunas_poligonos &lt;- readRDS(\"data/ine/Comunas_Chile.rds\") %&gt;% \n  select(-Shape_Leng, -Shape_Area)\n\n\nPuntos ComunalesPolígonos Comunales\n\n\n\n#convertir a puntos\ncomunas_point &lt;-  comunas_poligonos %&gt;% \n   st_centroid()\n\n\n#agregar los resultados de evolución\nvarianzas_w_points &lt;- comunas_point %&gt;%\n  left_join(varianzas_w, by  = \"COMUNA\") %&gt;% \n  mutate_if(.predicate = is.numeric,\n            .funs = function(x) ifelse(is.na(x), 0, x))\n\n# Inspección visual\n# r &lt;-  \"13\"\n# tipo_del &lt;- \"Desor\"\n# dif = filter(varianzas_w_points, REGION == r)\n# mapview::mapview(dif, zcol = tipo_del)\n\n\n#Guardar Resultados\nst_write(varianzas_w_points, \n         \"data/datos_trabajo_final/resultados/comdel_dif_points.shp\", \n         delete_dsn = T)\n\n\n\n\n#agregar los resultados de evolución\nvarianzas_w_pol &lt;- comunas_poligonos %&gt;%\n  left_join(varianzas_w, by  = \"COMUNA\") %&gt;% \n  mutate_if(.predicate = is.numeric,\n            .funs = function(x) ifelse(is.na(x), 0, x))\n\n\n# Inspección visual\n# r &lt;-  \"13\"\n# tipo_del &lt;- \"Desor\"\n# dif_pol = filter(varianzas_w_pol, REGION == r)\n# mapview::mapview(dif_pol, zcol = tipo_del)\n\n#Guardar Resultados\nst_write(varianzas_w_pol, \n         \"data/datos_trabajo_final/resultados/comdel_dif_pol.shp\", \n         delete_dsn = T)"
  },
  {
    "objectID": "clean.html#sec-categ",
    "href": "clean.html#sec-categ",
    "title": "2  Limpieza",
    "section": "2.7 Categorizar los delitos",
    "text": "2.7 Categorizar los delitos\nConsiderando que en los casos policiales tiene una diversa tipificación de delitos se procede a categorizarlos en grupos similares.\nPara facilitar el proceso de clasificación a cada tipo de delito se le asignará una Sigla que se encuentra en una hoja de un archivo excel.\n\ndel_sigla &lt;- read.xlsx(\"data/excel/delito_native.xlsx\", \n                       sheet = \"delitos\") %&gt;% \n  mutate(DELITO = toupper(DELITO)) %&gt;% \n  rename(Sigla =CATEGORIA)\nhead(del_sigla)\n\n  Sigla                                               DELITO\n1    vi ABANDONO DE CÓNYUGE O DE PARIENTES ENFERMOS ART. 352\n2  &lt;NA&gt;                         ABANDONO DE DESTINO ART. 254\n3    vi                                    ABANDONO DE HOGAR\n4    vi                    ABANDONO DE NIÑOS ART. 346 AL 351\n5    hr                               ABIGEATO ART. 448 BIS.\n6  &lt;NA&gt;             ABORTO COMETIDO POR FACULTATIVO ART. 345\n\n\nLa lista de categorías se encuentra en el mismo archivo Excel\n\ncategorias &lt;- read.xlsx(\"data/excel/delito_native.xlsx\", \n                        sheet = \"categorias\")\n  \nhead(categorias)\n\n      Tipo Sigla             Categoria Barrios_Comerciales\n1 Públicos    dd    Desordenes y daños                   0\n2 Públicos    ci       Comercio ilegal                   1\n3 Públicos    hr         Hurtos, robos                   1\n4 Públicos    rm Robos vehiculos motor                   1\n5 Públicos    rv   Robos con violencia                   1\n6 Públicos    rl      Riñas y lesiones                   0\n  Organizacion_criminal\n1                     0\n2                     1\n3                     0\n4                     1\n5                     0\n6                     0\n\n\nCon la sigla previamente creada se procede a categorizar cada uno de los casos policiales\n\ndelitos_cat &lt;- left_join(delitos_info, del_sigla,\n                         by = \"DELITO\")\n# head(delitos_cat)\n\n\n\ndelitos_cat &lt;- left_join(delitos_cat, categorias, \n                         by = \"Sigla\")\n# head(delitos_cat)\n\nGuardar los resultados\n\nsaveRDS(delitos_cat, \"data/delitos/delitos_all_categ.rds\")\n\nComo resultado del proceso anterior quedan muchos casos policiales sin categoría asignada los cuales se proceden a eliminar.\n\n# #Descartar los NA en Categoria\ndelitos_cat_sigla &lt;- delitos_cat%&gt;%\n  filter(!is.na(Categoria))\n\n# head(delitos_cat)\n# dim(delitos_cat_sigla)\n\nGuardar los resultados\n\nsaveRDS(delitos_cat_sigla, \"data/delitos/delitos_only_cat.rds\")"
  },
  {
    "objectID": "workflow.html#evolución-por-comunas",
    "href": "workflow.html#evolución-por-comunas",
    "title": "5  Workflow general",
    "section": "5.3 Evolución por Comunas",
    "text": "5.3 Evolución por Comunas\n\n\n\nFigure 5.3: Diagrama de flujo para el cáculo de evolución de delitos por Comunas\n\n\nCon el objetivo de medir la evolución de casos policiales en dos periodos de tiempo, se contruirá un indicador de variación de frecuencia a nivel comunal con representación espacial como punto y polígono.\nDe acuedo al diagrama de flujo de esta subsección Figure 5.3 se utilizará los resultados limpieza y codificación de tipos de delitos de casos policiales realizados anteriormente.\nPrimeramente se descartará la información de Denuncia Seguro, dejado solo la clasificación de “DENUNCIA” y “DETENCIÓN”\n\ndelcomuna &lt;- hechoscomunames %&gt;% \n  filter(CLASIFICAC %in% c(\"DENUNCIA\",\"DETENCION\"))\n\nSelección de Periodos, cálculo de frecuencias y variación\nTabla de medidas estadísticas de frecuencia de delitos\n\nvarianzas_base &lt;- delcomuna %&gt;% \n  group_by(COMUNA, TIPO) %&gt;% \n  summarise(varianza = sd(HECHOS),\n            cantidad = sum(HECHOS),  .groups = \"keep\")\n\nhead(varianzas_base)\n\n# A tibble: 6 × 4\n# Groups:   COMUNA, TIPO [6]\n  COMUNA TIPO               varianza cantidad\n  &lt;chr&gt;  &lt;chr&gt;                 &lt;dbl&gt;    &lt;int&gt;\n1 10101  Abandono familia      0            4\n2 10101  Abuso y Corrupción    0            2\n3 10101  Aprehensión           0.354        9\n4 10101  Armas                 0            3\n5 10101  Comercio ilegal       0            2\n6 10101  Daños                 0.316       11\n\n\n\nPeriodo 1\n\n\nini &lt;- delcomuna %&gt;%\n  filter(MESES %in% 201707:201712) %&gt;% \n  group_by(COMUNA, TIPO) %&gt;% \n  summarise(inicio = sum(HECHOS),  .groups = \"keep\")\n\n\nPeriodo 2\n\n\nfin &lt;- delcomuna %&gt;%\n  filter(MESES %in% 202207:202212) %&gt;% \n  group_by(COMUNA, TIPO) %&gt;% \n  summarise(fin = sum(HECHOS),  .groups = \"keep\")\n\n\nConsolidación\n\n\nadjvar &lt;- varianzas_base %&gt;% \n  left_join(ini, by = c(\"COMUNA\", \"TIPO\")) %&gt;% \n  left_join(fin, by = c(\"COMUNA\", \"TIPO\")) %&gt;% \n  mutate_if(.predicate = is.numeric,\n            .funs = function(x) ifelse(is.na(x), 0, x)) # si es NA -&gt; 0\n\n\nIndicador de Variación\n\n\nadjvar &lt;- adjvar %&gt;% \n  mutate(adjvar = (fin-inicio)/(fin+inicio)) %&gt;% \n  mutate_if(.predicate = is.numeric,\n            .funs = function(x) ifelse(is.na(x), 0, x))\nadjvar\n\n# A tibble: 2,076 × 7\n# Groups:   COMUNA, TIPO [2,076]\n   COMUNA TIPO               varianza cantidad inicio   fin adjvar\n   &lt;chr&gt;  &lt;chr&gt;                 &lt;dbl&gt;    &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 10101  Abandono familia      0            4      0     1      1\n 2 10101  Abuso y Corrupción    0            2      1     0     -1\n 3 10101  Aprehensión           0.354        9      4     0     -1\n 4 10101  Armas                 0            3      0     0      0\n 5 10101  Comercio ilegal       0            2      0     0      0\n 6 10101  Daños                 0.316       11      1     0     -1\n 7 10101  Delitos económicos    0            9      0     1      1\n 8 10101  Desacato              0            3      1     0     -1\n 9 10101  Desórdenes            0.648       67      6     6      0\n10 10101  Drogas                0            1      0     0      0\n# ℹ 2,066 more rows\n\n\n\nHistograma de las diferencias normalizadas entre periodos\n\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\nlibrary(hrbrthemes)\np &lt;- adjvar %&gt;%\n  ggplot( aes(x=adjvar)) +\n  geom_histogram( binwidth=0.1, \n                  fill=\"#69b3a2\", color=\"#e9ecef\", alpha=0.9) +\n  scale_x_continuous(breaks = seq(-1, 1, by = 0.2))+\n  ggtitle(\"Histograma de Variación Normalizada (muestra)\") +\n  theme_ipsum() +\n  theme(\n    plot.title = element_text(size=15)\n  )\np\n\n\n\n\n\nRelación del valor normalizado con la diferencia real\n\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\nvar_max &lt;- max(adjvar$fin-adjvar$inicio, na.rm = T)\na &lt;- 1\nb &lt;- 1:20\n\ndata &lt;- expand_grid(a, b) %&gt;% \n  mutate(cambio = (b-a)/(a+b))\n\nv &lt;- ggplot(data = data, aes(x = b, y = cambio))+\n  geom_line(color = \"#69b3a2\", linewidth =1)+\n  scale_y_continuous(breaks = seq(0, 1.2, by = 0.1))+\n  scale_x_continuous(breaks = seq(0, 20, by = 1))+\n  ggtitle(\"Representación de la Variación Normalizada\")+\n  theme_ipsum()+\n  theme_bw()\n\nv\n\n\n\n\nEstructuración en Panel Wide\nEn este paso cada Tipo de delitos será columna entonces los nombres se deben abreviar, pero de una forma segura, evitando la signación manual. Por lo anterior, este procedimiento se realizarà mediante un diccionario de abreviaciones, de la siguiente forma:\n\n# renombrar TIPO con diccionario\nabrev_tipos &lt;- read.xlsx(\"data/datos_trabajo_final/abreviaciones.xlsx\")\nabrev_tipos\n\n   Abreviacion        Tipo.delito\n1       AbCorr Abuso y Corrupción\n2        AbFam   Abandono familia\n3        AbSex       Abuso Sexual\n4        Apreh        Aprehensión\n5        Armas              Armas\n6        ComIl    Comercio ilegal\n7        Danos              Daños\n8        DelEc Delitos económicos\n9        Desac           Desacato\n10       Desor         Desórdenes\n11       Droga             Drogas\n12      HallMu   Hallazgo muertes\n13      HallVe  Hallazgo vehículo\n14       Homic         Homicidios\n15       HuRob     Hurtos y Robos\n16      LesGra    Lesiones graves\n17      PreDes Presunta desgracia\n18       RoDom     Robo domicilio\n19        RoVe     Robo vehículos\n20       RoVio      Robo violento\n21      Secues         Secuestros\n22       Trans           Tránsito\n23      TraPer     Trata personas\n24      VioFam Violencia familiar\n\n\nInsertar las abreviaciones a la base y reemplazar por TIPO\n\nadjvar &lt;- adjvar %&gt;% \n  left_join(abrev_tipos, by = c(\"TIPO\" = \"Tipo.delito\")) %&gt;% \n  mutate(TIPO = Abreviacion) %&gt;% \n  select(-Abreviacion)\nadjvar\n\n# A tibble: 2,076 × 7\n# Groups:   COMUNA, TIPO [2,076]\n   COMUNA TIPO   varianza cantidad inicio   fin adjvar\n   &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;    &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 10101  AbFam     0            4      0     1      1\n 2 10101  AbCorr    0            2      1     0     -1\n 3 10101  Apreh     0.354        9      4     0     -1\n 4 10101  Armas     0            3      0     0      0\n 5 10101  ComIl     0            2      0     0      0\n 6 10101  Danos     0.316       11      1     0     -1\n 7 10101  DelEc     0            9      0     1      1\n 8 10101  Desac     0            3      1     0     -1\n 9 10101  Desor     0.648       67      6     6      0\n10 10101  Droga     0            1      0     0      0\n# ℹ 2,066 more rows\n\n\nTransformar en formato wider\n\n# Pivot Wider\nvarianzas_w &lt;- adjvar%&gt;% \n  select(-varianza, -cantidad, -inicio, -fin ) %&gt;% \n  pivot_wider(names_from = TIPO,\n              values_from = c(adjvar), values_fill = 0) %&gt;% \n  mutate(COMUNA = sprintf(\"%05d\", as.numeric(COMUNA)))\nvarianzas_w\n\n# A tibble: 288 × 25\n# Groups:   COMUNA [288]\n   COMUNA AbFam AbCorr Apreh Armas ComIl Danos DelEc Desac Desor Droga HallMu\n   &lt;chr&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 10101      1     -1    -1     0     0    -1     1    -1     0     0      0\n 2 10102      0      0     0     0     0     0     0     0     0     0      0\n 3 10104      0      0     0     0     0     0     0     0     0     0      0\n 4 10105      0      0     0     0     0     0     0     0     1     0      0\n 5 10106      0      0     0     0     0     0     0     0     0     0      0\n 6 10107      0      0     0     0     0     0     0     0     1     0      0\n 7 10108      0      0     0     0     0     0     0     0     0     0      0\n 8 10109      0      0    -1     0     0     0    -1     0    -1     0      0\n 9 10201      0      0     0     0     0     0     0     0    -1     0      0\n10 10202      0      0     0     0     0     0     0     0     0     0      0\n# ℹ 278 more rows\n# ℹ 13 more variables: HuRob &lt;dbl&gt;, LesGra &lt;dbl&gt;, PreDes &lt;dbl&gt;, RoDom &lt;dbl&gt;,\n#   RoVe &lt;dbl&gt;, RoVio &lt;dbl&gt;, TraPer &lt;dbl&gt;, VioFam &lt;dbl&gt;, AbSex &lt;dbl&gt;,\n#   Trans &lt;dbl&gt;, HallVe &lt;dbl&gt;, Secues &lt;dbl&gt;, Homic &lt;dbl&gt;\n\n\nGuardar Resultados Espacial\n\nLectura de Archivo de poligonos comunales del INE\n\n\ncomunas_poligonos &lt;- readRDS(\"data/ine/Comunas_Chile.rds\") %&gt;% \n  select(-Shape_Leng, -Shape_Area)\n\n\nPuntos ComunalesPolígonos Comunales\n\n\n\n#convertir a puntos\ncomunas_point &lt;-  comunas_poligonos %&gt;% \n   st_centroid()\n\n\n#agregar los resultados de evolución\nvarianzas_w_points &lt;- comunas_point %&gt;%\n  left_join(varianzas_w, by  = \"COMUNA\") %&gt;% \n  mutate_if(.predicate = is.numeric,\n            .funs = function(x) ifelse(is.na(x), 0, x))\n\n# Inspección visual\n# r &lt;-  \"13\"\n# tipo_del &lt;- \"Desor\"\n# dif = filter(varianzas_w_points, REGION == r)\n# mapview::mapview(dif, zcol = tipo_del)\n\n\n#Guardar Resultados\nst_write(varianzas_w_points, \n         \"data/datos_trabajo_final/resultados/comdel_dif_points.shp\", \n         delete_dsn = T)\n\n\n\n\n#agregar los resultados de evolución\nvarianzas_w_pol &lt;- comunas_poligonos %&gt;%\n  left_join(varianzas_w, by  = \"COMUNA\") %&gt;% \n  mutate_if(.predicate = is.numeric,\n            .funs = function(x) ifelse(is.na(x), 0, x))\n\n\n# Inspección visual\n# r &lt;-  \"13\"\n# tipo_del &lt;- \"Desor\"\n# dif_pol = filter(varianzas_w_pol, REGION == r)\n# mapview::mapview(dif_pol, zcol = tipo_del)\n\n#Guardar Resultados\nst_write(varianzas_w_pol, \n         \"data/datos_trabajo_final/resultados/comdel_dif_pol.shp\", \n         delete_dsn = T)"
  },
  {
    "objectID": "workflow.html#evolución-por-zonas",
    "href": "workflow.html#evolución-por-zonas",
    "title": "5  Workflow general",
    "section": "5.4 Evolución por Zonas",
    "text": "5.4 Evolución por Zonas\n\n\n\nFigure 5.4: Diagrama de flujo para el cáculo de evolución de delitos por Zonas Censales\n\n\nCon el objetivo de medir la evolución de casos policiales en dos periodos de tiempo, se contruirá un indicador de evolución de frecuencia a nivel zona cenal con representación espacial como punto y polígono.\nDe acuedo al diagrama de flujo de esta subsección Figure 5.4 se utilizará los resultados de limpieza y codificación de tipos de delitos de casos policiales realizados anteriormente, pero esta vez agrupando por ZONA censal.\nLectura\nPara efectos de este libro digital se tomará una muestra de los casos policiales de 10000 a nivel nacional que ya habíamos enriquecido y limpiado en la etapa anterior:\n\ncasos &lt;- readRDS(\"data/datos_trabajo_final/resultados/casos_clean.rds\")\ncasos %&gt;% st_drop_geometry() %&gt;% count(TIPO)\n\n\n\n\nSelección de variables\nEn esta instación la variable que nos interesa es ZONA para poder realizar los cáculos de frecuencia por mes en cada zona y luego realizar la comparción entre períodos.\n\nhechos &lt;- casos %&gt;% \n  select(REGION,NOM_REGION,COMUNA,NOM_COMUNA,ZONA, MESES,TIPO,CLASIFICAC)\n\nContabilizar los Delitos\n\nhechosZonas &lt;- hechos %&gt;%\n  group_by(REGION,NOM_REGION,COMUNA,NOM_COMUNA,ZONA, MESES,CLASIFICAC,TIPO) %&gt;%\n  summarise(HECHOS = n(), .groups = \"keep\")\n\n# hechoscomunames\n\nfiltrar por fecha desde enero del 2017, encones podríamos filtar con la fechas superior al número 201700\n\nhechosZona &lt;- hechosZonas %&gt;% \n  filter(MESES &gt; 201700)\n\nSelección de Periodos, cálculo de frecuencias y variación\nTabla de medidas estadísticas de frecuencia de delitos\n\nvarianzas_base_z &lt;- hechosZonas %&gt;% \n  group_by(ZONA, TIPO) %&gt;% \n  summarise(varianza = sd(HECHOS),\n            cantidad = sum(HECHOS),  .groups = \"keep\")\n\nhead(varianzas_base)\n\n# A tibble: 6 × 4\n# Groups:   COMUNA, TIPO [6]\n  COMUNA TIPO               varianza cantidad\n  &lt;chr&gt;  &lt;chr&gt;                 &lt;dbl&gt;    &lt;int&gt;\n1 10101  Abandono familia      0            4\n2 10101  Abuso y Corrupción    0            2\n3 10101  Aprehensión           0.354        9\n4 10101  Armas                 0            3\n5 10101  Comercio ilegal       0            2\n6 10101  Daños                 0.316       11\n\n\n\nPeriodo 1\n\n\nini_z &lt;- hechosZonas %&gt;%\n  filter(MESES %in% 201707:201712) %&gt;% \n  group_by(ZONA, TIPO) %&gt;% \n  summarise(inicio = sum(HECHOS),  .groups = \"keep\")\n\n\nPeriodo 2\n\n\nfin_z &lt;- hechosZonas %&gt;%\n  filter(MESES %in% 202207:202212) %&gt;% \n  group_by(ZONA, TIPO) %&gt;% \n  summarise(fin = sum(HECHOS),  .groups = \"keep\")\n\n\nConsolidación\n\n\nadjvar &lt;- varianzas_base_z %&gt;% \n  left_join(ini_z, by = c(\"ZONA\", \"TIPO\")) %&gt;% \n  left_join(fin_z, by = c(\"ZONA\", \"TIPO\")) %&gt;% \n  mutate_if(.predicate = is.numeric,\n            .funs = function(x) ifelse(is.na(x), 0, x)) # si es NA -&gt; 0\n\n\nIndicador de Variación\n\n\nadjvar &lt;- adjvar %&gt;% \n  mutate(adjvar = (fin-inicio)/(fin+inicio)) %&gt;% \n  mutate_if(.predicate = is.numeric,\n            .funs = function(x) ifelse(is.na(x), 0, x))\nadjvar\n\n# A tibble: 7,152 × 7\n# Groups:   ZONA, TIPO [7,152]\n   ZONA        TIPO               varianza cantidad inicio   fin adjvar\n   &lt;chr&gt;       &lt;chr&gt;                 &lt;dbl&gt;    &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 10101011001 Abuso y Corrupción        0        1      0     0      0\n 2 10101011001 Comercio ilegal           0        1      0     0      0\n 3 10101011001 Daños                     0        3      0     0      0\n 4 10101011001 Delitos económicos        0        1      0     0      0\n 5 10101011001 Desórdenes                0        4      0     0      0\n 6 10101011001 Hurtos y Robos            0        3      0     1      1\n 7 10101011002 Delitos económicos        0        3      0     0      0\n 8 10101011002 Desórdenes                0        3      1     0     -1\n 9 10101011002 Hurtos y Robos            0        3      2     0     -1\n10 10101011002 Presunta desgracia        0        1      1     0     -1\n# ℹ 7,142 more rows\n\n\n\nHistograma de las diferencias normalizadas entre periodos\n\n\nPlotCode\n\n\n\n\n\n\n\n\n\n\nlibrary(hrbrthemes)\np &lt;- adjvar %&gt;%\n  ggplot( aes(x=adjvar)) +\n  geom_histogram( binwidth=0.1, \n                  fill=\"#69b3a2\", color=\"#e9ecef\", alpha=0.9) +\n  scale_x_continuous(breaks = seq(-1, 1, by = 0.2))+\n  ggtitle(\"Histograma de Variación Normalizada (muestra)\") +\n  theme_ipsum() +\n  theme(\n    plot.title = element_text(size=15)\n  )\np\n\n\n\n\nEstructuración en Panel Wide\nEn este paso cada Tipo de delitos será columna entonces los nombres se deben abreviar, pero de una forma segura, evitando la signación manual. Por lo anterior, se realizarà de la misma forma realizada anteriormente:\nInsertar las abreviaciones a la base y reemplazar por TIPO\n\nadjvar &lt;- adjvar %&gt;% \n  left_join(abrev_tipos, by = c(\"TIPO\" = \"Tipo.delito\")) %&gt;% \n  mutate(TIPO = Abreviacion) %&gt;% \n  select(-Abreviacion)\nadjvar\n\n# A tibble: 7,152 × 7\n# Groups:   ZONA, TIPO [7,152]\n   ZONA        TIPO   varianza cantidad inicio   fin adjvar\n   &lt;chr&gt;       &lt;chr&gt;     &lt;dbl&gt;    &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 10101011001 AbCorr        0        1      0     0      0\n 2 10101011001 ComIl         0        1      0     0      0\n 3 10101011001 Danos         0        3      0     0      0\n 4 10101011001 DelEc         0        1      0     0      0\n 5 10101011001 Desor         0        4      0     0      0\n 6 10101011001 HuRob         0        3      0     1      1\n 7 10101011002 DelEc         0        3      0     0      0\n 8 10101011002 Desor         0        3      1     0     -1\n 9 10101011002 HuRob         0        3      2     0     -1\n10 10101011002 PreDes        0        1      1     0     -1\n# ℹ 7,142 more rows\n\n\nTransformar en formato wider\n\n# Pivot Wider\nvarianzas_w_z &lt;- adjvar%&gt;% \n  select(-varianza, -cantidad, -inicio, -fin ) %&gt;% \n  pivot_wider(names_from = TIPO,\n              values_from = c(adjvar), values_fill = 0) \n# %&gt;% \n  # mutate(COMUNA = sprintf(\"%05d\", as.numeric(COMUNA)))\nvarianzas_w_z\n\n# A tibble: 3,385 × 25\n# Groups:   ZONA [3,385]\n   ZONA     AbCorr ComIl Danos DelEc Desor HuRob PreDes TraPer  RoVe AbFam Apreh\n   &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 1010101…      0     0     0     0     0     1      0      0     0     0     0\n 2 1010101…      0     0     0     0    -1    -1     -1      0     0     0     0\n 3 1010102…      0     0     0     0     0     0      0      0     0     0     0\n 4 1010102…      0     0     0     0     0     0      0      0     0     0     0\n 5 1010102…      0     0     0     0     1     0      0      0     0     0     0\n 6 1010102…      0     0     0     0    -1     0      0      0     0     0     0\n 7 1010102…      0     0     0     0     0     0      0      0     0     0     0\n 8 1010103…      0     0     0     0     0     0      0      0     0     0     0\n 9 1010103…      0     0     0     0     0     0      0      0     0     0     0\n10 1010103…      0     0     0     0     0     0      0      0     0     0     0\n# ℹ 3,375 more rows\n# ℹ 13 more variables: LesGra &lt;dbl&gt;, Armas &lt;dbl&gt;, RoVio &lt;dbl&gt;, VioFam &lt;dbl&gt;,\n#   RoDom &lt;dbl&gt;, Droga &lt;dbl&gt;, Desac &lt;dbl&gt;, HallMu &lt;dbl&gt;, AbSex &lt;dbl&gt;,\n#   Trans &lt;dbl&gt;, HallVe &lt;dbl&gt;, Secues &lt;dbl&gt;, Homic &lt;dbl&gt;\n\n\nGuardar Resultados Espacial\n\nLectura de Archivo de poligonos de zonas urbanas del INE\n\n\nzonas_poligonos &lt;- readRDS(\"data/ine/zonas_urb_consolidadas.rds\") %&gt;% \n  st_transform(4326) %&gt;%  # crs de latitud longitud\n  select(REGION, NOM_REGION, PROVINCIA, NOM_PROVIN,\n         COMUNA, NOM_COMUNA, URBANO, GEOCODIGO, AREA)\n\n\nPuntos ComunalesPolígonos Comunales\n\n\n\n#convertir a puntos\nzonas_point &lt;-  zonas_poligonos %&gt;% \n   st_centroid()\n\n\n#agregar los resultados de evolución\nvarianzas_w_points_z &lt;- zonas_point %&gt;%\n  left_join(varianzas_w_z, by  = c(\"GEOCODIGO\" = \"ZONA\")) %&gt;% \n  mutate_if(.predicate = is.numeric,\n            .funs = function(x) ifelse(is.na(x), 0, x))\n\n# Inspección visual\n# r &lt;-  \"13\"\n# tipo_del &lt;- \"Desor\"\n# dif = filter(varianzas_w_points_z, REGION == r)\n# mapview::mapview(dif, zcol = tipo_del)\n\n\n#Guardar Resultados\nst_write(varianzas_w_points_z, \n         \"data/datos_trabajo_final/resultados/zondel_dif_points.shp\", \n         delete_dsn = T)\n\n\n\n\n#agregar los resultados de evolución\nvarianzas_w_pol_z &lt;- zonas_poligonos %&gt;%\n  left_join(varianzas_w_z, by  =  c(\"GEOCODIGO\" = \"ZONA\")) %&gt;% \n  mutate_if(.predicate = is.numeric,\n            .funs = function(x) ifelse(is.na(x), 0, x))\n\n\n# Inspección visual\nr &lt;-  \"13\"\ntipo_del &lt;- \"Desor\"\ndif_pol = filter(varianzas_w_pol_z, REGION == r)\nmapview::mapview(dif_pol, zcol = tipo_del)\n\n#Guardar Resultados\nst_write(varianzas_w_pol_z, \n         \"data/datos_trabajo_final/resultados/zondel_dif_pol.shp\", \n         delete_dsn = T)"
  }
]